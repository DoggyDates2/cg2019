<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üêï Dog Walking Map v2.7 - With Color Persistence</title>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <!-- Leaflet Draw CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css" />
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
            width: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: #f8f9fa;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .controls {
            background: white;
            padding: 15px 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
            min-height: 60px;
            z-index: 1000;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .control-group label {
            font-weight: 600;
            color: #333;
            white-space: nowrap;
        }

        input[type="text"] {
            padding: 6px 10px;
            border: 2px solid #e1e5e9;
            border-radius: 6px;
            font-size: 14px;
            transition: border-color 0.2s;
            background: white;
            width: 200px;
        }

        input[type="text"]:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .group-filters {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .group-filter-btn {
            padding: 6px 12px;
            border: 2px solid #e1e5e9;
            border-radius: 6px;
            background: white;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s;
            font-size: 14px;
            user-select: none;
        }

        .group-filter-btn:hover:not(:disabled) {
            border-color: #667eea;
            transform: translateY(-1px);
        }

        .group-filter-btn.active {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }

        .selection-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            border-left: 2px solid #e1e5e9;
            padding-left: 20px;
        }

        .main-content {
            display: flex;
            flex: 1;
            overflow: hidden;
            position: relative;
            height: calc(100vh - 80px);
        }

        .left-panel {
            width: 300px;
            background: white;
            border-right: 2px solid #e1e5e9;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            z-index: 999;
            transition: transform 0.3s ease;
        }

        .panel-toggle {
            display: none;
            position: absolute;
            left: 300px;
            top: 50%;
            transform: translateY(-50%);
            background: white;
            border: 2px solid #e1e5e9;
            border-left: none;
            padding: 10px 5px;
            cursor: pointer;
            z-index: 1000;
            border-radius: 0 5px 5px 0;
        }

        @media (max-width: 768px) {
            .left-panel {
                position: absolute;
                left: 0;
                top: 0;
                bottom: 0;
                transform: translateX(-100%);
                box-shadow: 2px 0 5px rgba(0,0,0,0.1);
            }
            
            .left-panel.open {
                transform: translateX(0);
            }
            
            .panel-toggle {
                display: block;
                left: 0;
            }
            
            .left-panel.open ~ .panel-toggle {
                left: 300px;
            }
        }

        .legend-section {
            border-bottom: 1px solid #e1e5e9;
            padding: 8px;
            overflow-y: auto;
            flex: 1;
            scrollbar-width: thin;
            scrollbar-color: #ccc #f8f9fa;
        }

        .legend-section::-webkit-scrollbar {
            width: 6px;
        }

        .legend-section::-webkit-scrollbar-track {
            background: #f8f9fa;
        }

        .legend-section::-webkit-scrollbar-thumb {
            background: #ccc;
            border-radius: 3px;
        }

        .legend h3 {
            margin-bottom: 8px;
            color: #333;
            font-size: 15px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 1px;
            font-size: 12px;
            cursor: pointer;
            padding: 2px 4px;
            border-radius: 3px;
            transition: all 0.2s;
            border: 1px solid transparent;
            user-select: none;
        }

        .legend-item:hover {
            background-color: #f8f9fa;
            border-color: #dee2e6;
            transform: translateX(2px);
        }

        .legend-item.active {
            background-color: #e3f2fd;
            border-color: #2196F3;
            font-weight: bold;
        }

        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 6px;
            border: 2px solid #333;
            flex-shrink: 0;
        }

        .legend-text {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .color-picker {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            border: 1px solid #333;
            margin-left: 6px;
            cursor: pointer;
            flex-shrink: 0;
            padding: 0;
            background: none;
            opacity: 0.7;
            transition: opacity 0.2s;
        }

        .color-picker:hover {
            opacity: 1;
        }

        .color-picker::-webkit-color-swatch-wrapper {
            padding: 0;
            border-radius: 50%;
        }

        .color-picker::-webkit-color-swatch {
            border: none;
            border-radius: 50%;
        }

        .edit-section {
            padding: 16px;
            background: #f8f9fa;
        }

        #detailsContent {
            background: white;
            border-radius: 8px;
            padding: 16px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .dog-details {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .detail-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid #e1e5e9;
        }

        .detail-row:last-child {
            border-bottom: none;
        }

        .detail-label {
            font-weight: 600;
            color: #555;
            font-size: 13px;
            min-width: 80px;
        }

        .detail-value {
            flex: 1;
            text-align: right;
            font-size: 14px;
            color: #333;
        }

        .edit-driver-container {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .edit-driver-input {
            flex: 1;
            padding: 6px 8px;
            border: 2px solid #667eea;
            border-radius: 4px;
            font-size: 13px;
            background: white;
        }

        .edit-actions {
            display: flex;
            gap: 8px;
            margin-top: 12px;
        }

        .edit-actions button, .action-btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .save-btn {
            background: #667eea;
            color: white;
        }

        .save-btn:hover:not(:disabled) {
            background: #5a67d8;
            transform: translateY(-1px);
        }

        .save-btn:disabled {
            background: #cbd5e0;
            cursor: not-allowed;
            transform: none;
        }

        .cancel-btn {
            background: #e2e8f0;
            color: #333;
        }

        .cancel-btn:hover {
            background: #cbd5e0;
            transform: translateY(-1px);
        }

        #notification {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: white;
            padding: 12px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            display: none;
            z-index: 10000;
            max-width: 350px;
            border-left: 4px solid #667eea;
            animation: slideIn 0.3s ease-out;
        }

        #notification.success {
            border-left-color: #48bb78;
        }

        #notification.error {
            border-left-color: #f56565;
        }

        #notification.info {
            border-left-color: #4299e1;
        }

        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .notification-close {
            position: absolute;
            top: 8px;
            right: 8px;
            background: none;
            border: none;
            font-size: 18px;
            cursor: pointer;
            color: #666;
            line-height: 1;
            padding: 0;
        }

        .bulk-update-section {
            background: #f8f9fa;
            padding: 12px;
            margin: 16px 0;
            border-radius: 8px;
            border: 2px dashed #cbd5e0;
        }

        .bulk-update-section.active {
            border-color: #667eea;
            background: #edf2ff;
        }

        .bulk-input-group {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
        }

        .bulk-input {
            flex: 1;
            padding: 8px;
            border: 2px solid #e1e5e9;
            border-radius: 6px;
            font-size: 14px;
        }

        .bulk-stats {
            font-size: 14px;
            color: #555;
            margin-bottom: 8px;
            font-weight: 600;
        }

        .selected-count {
            background: #667eea;
            color: white;
            padding: 2px 8px;
            border-radius: 12px;
            margin-left: 8px;
        }

        #map {
            flex: 1;
            z-index: 1;
        }

        .no-selection {
            text-align: center;
            color: #999;
            padding: 20px;
            font-style: italic;
        }

        .search-hint {
            position: absolute;
            pointer-events: none;
            color: #999;
            left: 10px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 14px;
            white-space: nowrap;
        }

        .search-container {
            position: relative;
            display: flex;
            align-items: center;
        }

        /* Color Reset Button */
        .reset-colors-btn {
            padding: 6px 12px;
            border: 2px solid #ff6b6b;
            border-radius: 6px;
            background: white;
            color: #ff6b6b;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s;
            font-size: 14px;
        }

        .reset-colors-btn:hover {
            background: #ff6b6b;
            color: white;
            transform: translateY(-1px);
        }
    </style>
</head>
<body>
    <!-- Controls Bar -->
    <div class="controls">
        <div class="control-group">
            <label for="searchInput">Search Dogs:</label>
            <div class="search-container">
                <input type="text" id="searchInput" placeholder="Name or address...">
                <span id="searchHint" class="search-hint"></span>
            </div>
        </div>

        <div class="group-filters">
            <label>Groups:</label>
            <button id="group1Btn" class="group-filter-btn">Group 1</button>
            <button id="group2Btn" class="group-filter-btn">Group 2</button>
            <button id="group3Btn" class="group-filter-btn">Group 3</button>
            <button id="showAllBtn" class="group-filter-btn" style="background: #f8f9fa;">Show All</button>
        </div>

        <div class="selection-controls">
            <button id="selectionModeBtn" class="group-filter-btn">üìç Selection Mode</button>
            <button id="clearSelectionBtn" class="group-filter-btn" style="display: none;">Clear Selection</button>
            <button id="resetColorsBtn" class="reset-colors-btn" title="Clear all saved colors">üé® Reset Colors</button>
        </div>
    </div>

    <!-- Main Content Area -->
    <div class="main-content">
        <!-- Left Panel -->
        <div class="left-panel" id="leftPanel">
            <!-- Legend Section -->
            <div class="legend-section">
                <div class="legend" id="legendContainer">
                    <h3>Drivers</h3>
                    <div id="legendItems"></div>
                </div>
            </div>

            <!-- Edit Section -->
            <div class="edit-section">
                <h3>Edit Marker</h3>
                <div id="detailsContent">
                    <div class="no-selection">Click a marker to edit</div>
                </div>
                
                <!-- Bulk Update Section (only visible in selection mode) -->
                <div id="bulkUpdateSection" class="bulk-update-section" style="display: none;">
                    <div class="bulk-stats">
                        <span>Bulk Update</span>
                        <span class="selected-count" id="selectedCount">0 selected</span>
                    </div>
                    <div class="bulk-input-group">
                        <input type="text" id="bulkDriverInput" class="bulk-input" placeholder="Driver name">
                    </div>
                    <button id="bulkUpdateBtn" class="save-btn" onclick="bulkUpdateSelected()">üíæ Update All</button>
                </div>
            </div>
        </div>

        <!-- Panel Toggle (for mobile) -->
        <button class="panel-toggle" id="panelToggle">‚óÄ</button>

        <!-- Map Container -->
        <div id="map"></div>
    </div>

    <!-- Notification -->
    <div id="notification" class="notification">
        <button class="notification-close" onclick="this.parentElement.style.display='none'">√ó</button>
        <div id="notificationText"></div>
    </div>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <!-- Leaflet Draw JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>
    <!-- PapaParse for CSV -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script>
    
    <script>
// ==================== COLOR PERSISTENCE FUNCTIONS ====================
// These functions handle saving and loading driver colors from localStorage

function saveDriverColor(driverName, color) {
    try {
        const savedColors = JSON.parse(localStorage.getItem('driverColors') || '{}');
        savedColors[driverName] = color;
        localStorage.setItem('driverColors', JSON.stringify(savedColors));
        console.log(`Saved color for ${driverName}: ${color}`);
    } catch (error) {
        console.error('Error saving driver color:', error);
    }
}

function loadSavedColors() {
    try {
        const savedColors = JSON.parse(localStorage.getItem('driverColors') || '{}');
        console.log('Loaded saved colors:', savedColors);
        return savedColors;
    } catch (error) {
        console.error('Error loading saved colors:', error);
        return {};
    }
}

function resetColors() {
    if (confirm('This will reset all custom driver colors to defaults. Are you sure?')) {
        localStorage.removeItem('driverColors');
        state.driverColors = {};
        assignDriverColors();
        updateMap();
        showNotification('Colors reset to defaults', 'success');
    }
}

// ==================== CONFIGURATION ====================
const CONFIG = {
    BOUNDS: [[42.68, -71.13], [42.73, -71.06]],
    CENTER: [42.7094, -71.1077],
    ZOOM: 14,
    MIN_ZOOM: 12,
    MAX_ZOOM: 18,
    CSV_URL: 'https://docs.google.com/spreadsheets/d/e/2PACX-1vRxdTBQOQbvb9s4_JAL3aJJJRV0jAamQEQv_C0fmZGaZW0iJkNJ82FOmLf4gGHvqVLv2QuVt_ZAa8Qf/pub?gid=0&single=true&output=csv',
    CSV_CACHE_TIME: 30000,
    DEBOUNCE_DELAY: 300,
    RAINBOW_COLORS: [
        '#FF0000', '#FF4500', '#FFA500', '#FFD700', '#FFFF00',
        '#ADFF2F', '#00FF00', '#00CED1', '#0000FF', '#4B0082',
        '#8B008B', '#FF1493', '#FF69B4', '#FF6347', '#40E0D0'
    ],
    WEB_APP_URL: 'https://script.google.com/macros/s/AKfycbx_xt5HXzoFo5VcX-b9TUOBXCZJlCcJCt3xSJLAQKZzCLXpZmYL7EfXMELVX2vw4UF4/exec'
};

// ==================== APPLICATION STATE ====================
const state = {
    map: null,
    allData: [],
    filteredData: [],
    markers: [],
    layerGroups: {
        1: null,
        2: null,
        3: null
    },
    markerLookup: new Map(),
    coordinateLookup: new Map(),
    lastCsvLoad: 0,
    selectedMarker: null,
    selectedRow: null,
    selectionMode: false,
    selectedMarkers: new Set(),
    activeGroupFilters: new Set(),
    driverColors: {},
    activeDriver: null,
    searchInput: null,
    searchMatches: [],
    currentMatchIndex: -1
};

// ==================== UTILITY FUNCTIONS ====================
function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
        const later = () => {
            clearTimeout(timeout);
            func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    };
}

function showNotification(message, type = 'info', duration = 3000) {
    const notification = document.getElementById('notification');
    const notificationText = document.getElementById('notificationText');
    
    if (notification && notificationText) {
        notificationText.textContent = message;
        notification.className = `notification ${type}`;
        notification.style.display = 'block';
        
        if (duration > 0) {
            setTimeout(() => {
                notification.style.display = 'none';
            }, duration);
        }
    } else {
        console.log(`[${type.toUpperCase()}] ${message}`);
    }
}

function parseGroup(groupValue) {
    if (!groupValue || groupValue === '') return [];
    
    const groupStr = String(groupValue).trim().toUpperCase();
    const groups = [];
    
    const singlePattern = /^([123])([A-Z]*)\d*$/;
    const singleMatch = groupStr.match(singlePattern);
    if (singleMatch) {
        groups.push(parseInt(singleMatch[1]));
        return groups;
    }
    
    const doublePattern = /^([123])[A-Z]*&([123])[A-Z]*\d*$/;
    const doubleMatch = groupStr.match(doublePattern);
    if (doubleMatch) {
        groups.push(parseInt(doubleMatch[1]));
        groups.push(parseInt(doubleMatch[2]));
        return groups;
    }
    
    const triplePattern = /^([123])([A-Z]*)([123])([123])$/;
    const tripleMatch = groupStr.match(triplePattern);
    if (tripleMatch) {
        groups.push(parseInt(tripleMatch[1]));
        groups.push(parseInt(tripleMatch[3]));
        groups.push(parseInt(tripleMatch[4]));
        return groups;
    }
    
    console.log('No pattern matched for group value:', groupValue);
    return groups;
}

function assignDriverColors() {
    const drivers = new Set();
    state.allData.forEach(row => {
        if (row['Driver'] && row['Driver'].trim()) {
            drivers.add(row['Driver'].trim());
        }
    });

    const sortedDrivers = Array.from(drivers).sort();
    
    // Load saved colors first
    const savedColors = loadSavedColors();
    
    // Reset driver colors but keep saved ones
    state.driverColors = {};
    
    sortedDrivers.forEach((driver, index) => {
        // Check if we have a saved color for this driver
        if (savedColors[driver]) {
            state.driverColors[driver] = savedColors[driver];
        } else {
            // Assign default color
            state.driverColors[driver] = CONFIG.RAINBOW_COLORS[index % CONFIG.RAINBOW_COLORS.length];
        }
    });

    updateLegend();
}

function createIcon(color, isSelected = false, isActiveDriver = false) {
    let size = 10;
    let borderWidth = 2;
    
    if (isSelected) {
        size = 14;
        borderWidth = 3;
    } else if (isActiveDriver) {
        size = 12;
        borderWidth = 2.5;
    }
    
    const svgIcon = `
        <svg width="${size * 2}" height="${size * 2}" xmlns="http://www.w3.org/2000/svg">
            <circle cx="${size}" cy="${size}" r="${size - borderWidth}" 
                    fill="${color}" 
                    stroke="${isSelected ? '#FFD700' : '#333'}" 
                    stroke-width="${borderWidth}"/>
        </svg>
    `;
    
    return L.divIcon({
        html: svgIcon,
        iconSize: [size * 2, size * 2],
        iconAnchor: [size, size],
        className: 'custom-marker-icon'
    });
}

// ==================== AUTOCOMPLETE FUNCTIONALITY ====================
function setupAutocomplete(searchInput, searchHint) {
    if (!searchInput || !searchHint) return;

    let currentSuggestion = '';
    
    function getAllSearchableText() {
        const searchableTexts = new Set();
        
        state.allData.forEach(row => {
            if (row['Dog Name']) searchableTexts.add(row['Dog Name']);
            if (row['Address']) searchableTexts.add(row['Address']);
            if (row['Driver']) searchableTexts.add(row['Driver']);
        });
        
        return Array.from(searchableTexts).sort();
    }
    
    function updateHint() {
        const inputValue = searchInput.value.toLowerCase();
        searchHint.textContent = '';
        currentSuggestion = '';
        
        if (!inputValue) return;
        
        const allTexts = getAllSearchableText();
        const match = allTexts.find(text => 
            text.toLowerCase().startsWith(inputValue) && 
            text.toLowerCase() !== inputValue
        );
        
        if (match) {
            currentSuggestion = match;
            const visiblePart = match.substring(inputValue.length);
            searchHint.textContent = searchInput.value + visiblePart;
        }
    }
    
    searchInput.addEventListener('input', updateHint);
    
    searchInput.addEventListener('keydown', function(e) {
        if (e.key === 'Tab' && currentSuggestion) {
            e.preventDefault();
            searchInput.value = currentSuggestion;
            searchHint.textContent = '';
            currentSuggestion = '';
            debouncedUpdateMap();
        }
    });
    
    searchInput.addEventListener('blur', function() {
        searchHint.textContent = '';
    });
}

// ==================== LEGEND MANAGEMENT ====================
function updateLegend() {
    const legendItems = document.getElementById('legendItems');
    if (!legendItems) return;
    
    legendItems.innerHTML = '';
    
    const sortedDrivers = Object.keys(state.driverColors).sort();
    
    sortedDrivers.forEach(driver => {
        const color = state.driverColors[driver];
        const legendItem = document.createElement('div');
        legendItem.className = 'legend-item';
        legendItem.dataset.driver = driver;
        
        if (state.activeDriver === driver) {
            legendItem.classList.add('active');
        }
        
        legendItem.innerHTML = `
            <span class="legend-color" style="background-color: ${color}"></span>
            <span class="legend-text">${driver}</span>
            <input type="color" class="color-picker" value="${color}" data-driver="${driver}">
        `;
        
        legendItem.querySelector('.legend-text').addEventListener('click', (e) => {
            filterByCategory('Driver', driver);
            
            document.querySelectorAll('.legend-item').forEach(item => {
                item.classList.remove('active');
            });
            legendItem.classList.add('active');
        });
        
        const colorPicker = legendItem.querySelector('.color-picker');
        colorPicker.addEventListener('change', (e) => {
            const newColor = e.target.value;
            state.driverColors[driver] = newColor;
            saveDriverColor(driver, newColor);  // Save to localStorage
            legendItem.querySelector('.legend-color').style.backgroundColor = newColor;
            updateMap();
        });
        
        colorPicker.addEventListener('click', (e) => {
            e.stopPropagation();
        });
        
        legendItems.appendChild(legendItem);
    });
}

// ==================== MAP INITIALIZATION ====================
function initMap() {
    console.log('Initializing map...');
    
    state.map = L.map('map', {
        zoomControl: true,
        attributionControl: true,
        maxBounds: L.latLngBounds(
            [CONFIG.BOUNDS[0][0] - 0.1, CONFIG.BOUNDS[0][1] - 0.1],
            [CONFIG.BOUNDS[1][0] + 0.1, CONFIG.BOUNDS[1][1] + 0.1]
        )
    }).setView(CONFIG.CENTER, CONFIG.ZOOM);

    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: CONFIG.MAX_ZOOM,
        minZoom: CONFIG.MIN_ZOOM,
        attribution: '¬© OpenStreetMap contributors'
    }).addTo(state.map);
    
    state.layerGroups[1] = L.layerGroup().addTo(state.map);
    state.layerGroups[2] = L.layerGroup().addTo(state.map);
    state.layerGroups[3] = L.layerGroup().addTo(state.map);
    
    L.control.zoom({
        position: 'topright'
    }).addTo(state.map);
    
    console.log('Map initialized successfully');
}

// ==================== DATA LOADING ====================
async function loadData() {
    const now = Date.now();
    if (now - state.lastCsvLoad < CONFIG.CSV_CACHE_TIME && state.allData.length > 0) {
        console.log('Using cached data');
        updateMap();
        return;
    }

    console.log('Loading data from Google Sheets...');
    showNotification('Loading data...', 'info');

    try {
        const response = await fetch(CONFIG.CSV_URL);
        
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const csvText = await response.text();
        
        if (!csvText || csvText.trim() === '') {
            throw new Error('Received empty CSV data');
        }
        
        Papa.parse(csvText, {
            header: true,
            skipEmptyLines: true,
            complete: function(results) {
                console.log('CSV parsed successfully');
                console.log(`Loaded ${results.data.length} rows`);
                
                state.allData = results.data.map((row, index) => {
                    row._rowIndex = index;
                    return row;
                });
                
                state.lastCsvLoad = now;
                
                assignDriverColors();
                updateMap();
                showNotification('Data loaded successfully!', 'success');
            },
            error: function(error) {
                console.error('Papa Parse error:', error);
                showNotification('Error parsing CSV data', 'error');
            }
        });
        
    } catch (error) {
        console.error('Error loading data:', error);
        showNotification(`Error loading data: ${error.message}`, 'error');
    }
}

// ==================== MAP UPDATE ====================
function updateMap() {
    if (!state.map) {
        console.warn('Map not initialized yet');
        return;
    }
    
    console.log('Updating map...');
    
    state.markers.forEach(markerData => {
        if (markerData && markerData.marker && state.map.hasLayer(markerData.marker)) {
            state.map.removeLayer(markerData.marker);
        }
    });
    state.markers = [];
    
    state.markerLookup.clear();
    state.coordinateLookup.clear();
    
    Object.values(state.layerGroups).forEach(group => {
        if (group) group.clearLayers();
    });
    
    const searchValue = document.getElementById('searchInput')?.value.toLowerCase() || '';
    
    state.filteredData = state.allData.filter(row => {
        if (!row) return false;
        
        if (searchValue) {
            const dogName = (row['Dog Name'] || '').toLowerCase();
            const address = (row['Address'] || '').toLowerCase();
            const driver = (row['Driver'] || '').toLowerCase();
            const searchMatch = dogName.includes(searchValue) || 
                              address.includes(searchValue) ||
                              driver.includes(searchValue);
            
            if (!searchMatch) return false;
        }
        
        if (state.activeDriver) {
            if (row['Driver'] !== state.activeDriver) return false;
        }
        
        if (state.activeGroupFilters.size > 0) {
            const groups = parseGroup(row['Group']);
            const hasMatchingGroup = groups.some(g => state.activeGroupFilters.has(g));
            if (!hasMatchingGroup) return false;
        }
        
        return true;
    });
    
    const groupCounts = { 1: 0, 2: 0, 3: 0 };
    
    state.filteredData.forEach((row, index) => {
        const lat = parseFloat(row['Lat']);
        const lng = parseFloat(row['Long']);
        const dogName = row['Dog Name'] || 'Unknown';
        const dogId = row['Id'] || `${dogName}-${index}`;
        
        if (!isNaN(lat) && !isNaN(lng)) {
            const groups = parseGroup(row['Group']);
            
            if (groups.length === 0) {
                console.warn(`No valid group for dog: ${dogName}`);
                return;
            }
            
            const primaryGroup = groups[0];
            const color = state.driverColors[row['Driver']] || '#808080';
            
            const coordKey = `${lat.toFixed(6)},${lng.toFixed(6)}`;
            if (!state.coordinateLookup.has(coordKey)) {
                state.coordinateLookup.set(coordKey, []);
            }
            state.coordinateLookup.get(coordKey).push(dogId);
            
            const isSelected = state.selectedMarkers.has(dogId);
            const isActiveDriver = state.activeDriver && row['Driver'] === state.activeDriver;
            const marker = L.marker([lat, lng], {
                icon: createIcon(color, isSelected, isActiveDriver)
            });
            
            const popupContent = `
                <div style="min-width: 200px;">
                    <strong>${dogName}</strong><br>
                    ${row['Address'] || 'No address'}<br>
                    Driver: ${row['Driver'] || 'Unassigned'}<br>
                    Group: ${row['Group'] || 'None'}<br>
                    ${row['Comments'] ? `<br><em>${row['Comments']}</em>` : ''}
                </div>
            `;
            
            marker.bindPopup(popupContent);
            
            marker.bindTooltip(dogName, {
                permanent: false,
                direction: 'top',
                offset: [0, -10]
            });
            
            marker.on('click', () => {
                if (state.selectionMode) {
                    toggleMarkerSelection(dogId, marker, row);
                } else {
                    selectMarker(marker, row, index, primaryGroup);
                }
            });
            
            if (state.layerGroups[primaryGroup]) {
                marker.addTo(state.layerGroups[primaryGroup]);
            } else {
                console.warn(`No layer group for group ${primaryGroup}`);
            }
            
            const markerData = { 
                marker, 
                row, 
                dogId,
                group: primaryGroup
            };
            state.markers.push(markerData);
            state.markerLookup.set(dogId, markerData);
            
            groupCounts[primaryGroup]++;
        }
    });
    
    console.log('Group counts:', groupCounts);
    console.log(`Map updated with ${state.markers.length} markers`);
}

// ==================== MARKER SELECTION ====================
function selectMarker(marker, row, index, group) {
    state.selectedMarker = marker;
    state.selectedRow = row;
    
    const detailsContent = document.getElementById('detailsContent');
    if (!detailsContent) return;
    
    const saveId = `save-${row['Id'] || index}`;
    const inputId = `driver-${row['Id'] || index}`;
    
    detailsContent.innerHTML = `
        <div class="dog-details">
            <div class="detail-row">
                <span class="detail-label">Name:</span>
                <span class="detail-value">${row['Dog Name'] || 'Unknown'}</span>
            </div>
            <div class="detail-row">
                <span class="detail-label">Address:</span>
                <span class="detail-value">${row['Address'] || 'No address'}</span>
            </div>
            <div class="detail-row">
                <span class="detail-label">Group:</span>
                <span class="detail-value">${row['Group'] || 'None'}</span>
            </div>
            <div class="detail-row">
                <span class="detail-label">Driver:</span>
                <div class="detail-value edit-driver-container">
                    <input type="text" 
                           id="${inputId}" 
                           class="edit-driver-input" 
                           value="${row['Driver'] || ''}" 
                           placeholder="Enter driver name"
                           list="driverSuggestions">
                </div>
            </div>
            ${row['Comments'] ? `
            <div class="detail-row">
                <span class="detail-label">Comments:</span>
                <span class="detail-value">${row['Comments']}</span>
            </div>
            ` : ''}
            <div class="edit-actions">
                <button id="${saveId}" class="save-btn" onclick="saveDriverName()">üíæ Save</button>
                <button class="cancel-btn" onclick="cancelEdit()">Cancel</button>
            </div>
        </div>
        <datalist id="driverSuggestions">
            ${Object.keys(state.driverColors).map(driver => 
                `<option value="${driver}">`
            ).join('')}
        </datalist>
    `;
    
    const driverInput = document.getElementById(inputId);
    if (driverInput) {
        driverInput.focus();
        driverInput.select();
        
        driverInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                saveDriverName();
            }
        });
    }
}

function toggleMarkerSelection(dogId, marker, row) {
    if (state.selectedMarkers.has(dogId)) {
        state.selectedMarkers.delete(dogId);
    } else {
        state.selectedMarkers.add(dogId);
    }
    
    updateSelectionUI();
    
    const color = state.driverColors[row['Driver']] || '#808080';
    const isSelected = state.selectedMarkers.has(dogId);
    marker.setIcon(createIcon(color, isSelected));
}

function updateSelectionUI() {
    const count = state.selectedMarkers.size;
    const selectedCount = document.getElementById('selectedCount');
    const clearBtn = document.getElementById('clearSelectionBtn');
    
    if (selectedCount) {
        selectedCount.textContent = `${count} selected`;
    }
    
    if (clearBtn) {
        clearBtn.style.display = count > 0 ? 'inline-block' : 'none';
    }
}

// ==================== SELECTION MODE ====================
function toggleSelectionMode() {
    state.selectionMode = !state.selectionMode;
    
    const btn = document.getElementById('selectionModeBtn');
    const bulkSection = document.getElementById('bulkUpdateSection');
    
    if (btn) {
        btn.classList.toggle('active', state.selectionMode);
        btn.textContent = state.selectionMode ? '‚úì Selection Mode' : 'üìç Selection Mode';
    }
    
    if (bulkSection) {
        bulkSection.style.display = state.selectionMode ? 'block' : 'none';
        if (state.selectionMode) {
            bulkSection.classList.add('active');
        } else {
            bulkSection.classList.remove('active');
        }
    }
    
    if (!state.selectionMode) {
        clearSelection();
    }
    
    updateSelectionUI();
}

function clearSelection() {
    state.selectedMarkers.clear();
    updateSelectionUI();
    updateMap();
}

// ==================== FILTERING ====================
function toggleGroupFilter(group) {
    if (state.activeGroupFilters.has(group)) {
        state.activeGroupFilters.delete(group);
    } else {
        state.activeGroupFilters.add(group);
    }
    
    const btn = document.getElementById(`group${group}Btn`);
    if (btn) {
        btn.classList.toggle('active', state.activeGroupFilters.has(group));
    }
    
    updateMap();
}

function clearFilter() {
    state.activeGroupFilters.clear();
    state.activeDriver = null;
    
    document.querySelectorAll('.group-filter-btn').forEach(btn => {
        btn.classList.remove('active');
    });
    
    document.querySelectorAll('.legend-item').forEach(item => {
        item.classList.remove('active');
    });
    
    updateMap();
}

function filterByCategory(category, value) {
    if (category === 'Driver') {
        if (state.activeDriver === value) {
            state.activeDriver = null;
        } else {
            state.activeDriver = value;
        }
        updateMap();
    }
}

// ==================== PANEL TOGGLE ====================
function togglePanel() {
    const panel = document.getElementById('leftPanel');
    const toggle = document.getElementById('panelToggle');
    
    if (panel) {
        panel.classList.toggle('open');
        if (toggle) {
            toggle.textContent = panel.classList.contains('open') ? '‚óÄ' : '‚ñ∂';
        }
    }
}

// ==================== GOOGLE SHEETS INTEGRATION ====================
async function callAppsScript(payload) {
    try {
        const response = await fetch(CONFIG.WEB_APP_URL, {
            method: 'POST',
            mode: 'no-cors',
            cache: 'no-cache',
            headers: {
                'Content-Type': 'text/plain',
            },
            body: JSON.stringify(payload)
        });
        
        console.log('Request sent to Google Apps Script');
        return { success: true };
    } catch (error) {
        console.error('Error calling Apps Script:', error);
        throw error;
    }
}

async function testAppsScriptConnection() {
    console.log('Testing Google Apps Script connection...');
    showNotification('Testing connection to Google Sheets...', 'info');
    
    try {
        const testPayload = {
            action: 'test',
            timestamp: new Date().toISOString()
        };
        
        await callAppsScript(testPayload);
        
        showNotification('‚úÖ Connection test sent successfully! Check Google Sheets for confirmation.', 'success', 5000);
        console.log('Connection test completed successfully');
        
    } catch (error) {
        console.error('Connection test failed:', error);
        showNotification(`‚ùå Connection test failed: ${error.message}`, 'error');
    }
}

function getSheetRowIndex(row) {
    const allDataIndex = state.allData.indexOf(row);
    if (allDataIndex === -1) {
        if (row._rowIndex !== undefined) {
            return row._rowIndex + 2;
        }
        console.warn('Row not found in data array and no _rowIndex property');
        return -1;
    }
    return allDataIndex + 2;
}

async function saveMarkerData() {
    if (!state.selectedRow) {
        showNotification('No marker selected', 'error');
        return;
    }
    
    const inputId = `driver-${state.selectedRow['Id'] || state.selectedRow._rowIndex}`;
    const saveBtn = document.querySelector(`#save-${state.selectedRow['Id'] || state.selectedRow._rowIndex}`);
    const driverInput = document.getElementById(inputId);
    
    if (!driverInput) {
        showNotification('Cannot find driver input field', 'error');
        return;
    }
    
    const newDriverName = driverInput.value.trim();
    const oldDriver = state.selectedRow['Driver'] || '';
    
    if (newDriverName === oldDriver) {
        showNotification('No changes to save', 'info');
        return;
    }
    
    const sheetRowIndex = getSheetRowIndex(state.selectedRow);
    
    if (sheetRowIndex === -1) {
        showNotification('Cannot determine row position in sheet', 'error');
        return;
    }
    
    const oldGroup = state.selectedRow['Group'];
    
    try {
        if (saveBtn) {
            saveBtn.disabled = true;
            saveBtn.innerHTML = '‚è≥ Saving...';
        }
        
        state.selectedRow['Driver'] = newDriverName;
        
        assignDriverColors();
        updateMap();
        
        showNotification('Saving to Google Sheets...', 'info');
        
        const payload = {
            action: 'update',
            rowIndex: sheetRowIndex,
            updatedData: {
                'Driver': newDriverName
            }
        };
        
        console.log('Saving to row:', sheetRowIndex);
        console.log('New driver value:', newDriverName);
        
        await callAppsScript(payload);
        
        showNotification('‚úÖ Successfully saved to Google Sheets!', 'success', 3000);
        
        if (saveBtn) {
            saveBtn.disabled = false;
            saveBtn.innerHTML = 'üíæ Save';
        }
        
        if (state.selectedMarker) {
            const groups = parseGroup(oldGroup);
            if (groups.length > 0) {
                selectMarker(state.selectedMarker, state.selectedRow, state.selectedRow._rowIndex, groups[0]);
            }
        }
        
        setTimeout(() => {
            console.log('Reloading data to sync with Google Sheets...');
            loadData();
        }, 500);
        
    } catch (error) {
        console.error('Save error:', error);
        showNotification(`Error saving: ${error.message}`, 'error');
        
        if (saveBtn) {
            saveBtn.disabled = false;
            saveBtn.innerHTML = 'üíæ Save';
        }
        
        if (state.selectedRow && typeof oldDriver !== 'undefined') {
            state.selectedRow['Driver'] = oldDriver;
            state.selectedRow['Group'] = oldGroup;
            assignDriverColors();
            updateMap();
        }
    }
}

async function saveDriverName() {
    return saveMarkerData();
}

async function bulkUpdateSelected() {
    if (!state.selectionMode) {
        showNotification('Not in selection mode', 'error');
        return;
    }
    
    const bulkInput = document.getElementById('bulkDriverInput');
    const bulkBtn = document.getElementById('bulkUpdateBtn');
    
    if (!bulkInput) {
        showNotification('Interface not ready. Please try again.', 'error');
        return;
    }
    
    const newDriverName = bulkInput.value.trim();
    if (!newDriverName) {
        showNotification('Please enter a driver name', 'error');
        bulkInput.focus();
        return;
    }
    
    if (state.selectedMarkers.size === 0) {
        showNotification('No markers selected', 'error');
        return;
    }
    
    try {
        const validSelectedRows = [];
        const sheetRowIndices = [];
        
        for (const dogId of state.selectedMarkers) {
            const markerData = state.markerLookup.get(dogId);
            if (markerData && markerData.row) {
                const sheetRowIndex = getSheetRowIndex(markerData.row);
                if (sheetRowIndex !== -1) {
                    validSelectedRows.push(markerData.row);
                    sheetRowIndices.push(sheetRowIndex);
                }
            }
        }
        
        if (validSelectedRows.length === 0) {
            showNotification('No valid markers selected', 'error');
            return;
        }
        
        if (!confirm(`Update ${validSelectedRows.length} dogs with driver name: "${newDriverName}"?`)) {
            return;
        }
        
        if (bulkBtn) {
            bulkBtn.disabled = true;
            bulkBtn.innerHTML = '‚è≥ Updating...';
        }
        
        const oldValues = validSelectedRows.map(row => ({
            row: row,
            oldDriver: row['Driver'] || ''
        }));
        
        validSelectedRows.forEach(row => {
            row['Driver'] = newDriverName;
        });
        
        state.markerLookup.clear();
        state.coordinateLookup.clear();
        
        assignDriverColors();
        updateMap();
        clearSelection();
        
        showNotification(`Saving ${validSelectedRows.length} updates to Google Sheets...`, 'info');
        
        const updates = sheetRowIndices.map(sheetRowIndex => ({
            rowIndex: sheetRowIndex,
            updatedData: {
                'Driver': newDriverName
            }
        }));
        
        console.log('Bulk updating rows:', sheetRowIndices);
        
        const payload = {
            action: 'bulkUpdate',
            updates: updates
        };
        
        await callAppsScript(payload);
        
        showNotification(`‚úÖ Successfully updated ${validSelectedRows.length} dogs in Google Sheets!`, 'success', 3000);
        
        if (bulkBtn) {
            bulkBtn.disabled = false;
            bulkBtn.innerHTML = 'üíæ Update All';
        }
        
        setTimeout(() => {
            console.log('Reloading data to refresh tooltips after bulk update...');
            loadData();
        }, 500);
        
    } catch (error) {
        console.error('Bulk update error:', error);
        showNotification(`Error during bulk update: ${error.message}`, 'error');
        
        if (bulkBtn) {
            bulkBtn.disabled = false;
            bulkBtn.innerHTML = 'üíæ Update All';
        }
        
        if (oldValues) {
            oldValues.forEach(({row, oldDriver}) => {
                row['Driver'] = oldDriver;
            });
            assignDriverColors();
            updateMap();
        }
    }
}

function cancelEdit() {
    if (state.selectedMarker && state.selectedRow) {
        const markerData = state.markers.find(m => m && m.marker === state.selectedMarker);
        if (markerData) {
            const index = state.selectedRow['_rowIndex'] ?? state.allData.indexOf(state.selectedRow);
            selectMarker(state.selectedMarker, state.selectedRow, index, markerData.group);
        }
    }
}

// ==================== INITIALIZATION ====================
const debouncedUpdateMap = debounce(updateMap, CONFIG.DEBOUNCE_DELAY);

function initializeApp() {
    try {
        console.log('DOM loaded, initializing application...');
        
        const requiredFeatures = [
            'Promise' in window,
            'fetch' in window,
            'Map' in window,
            'Set' in window,
            'requestAnimationFrame' in window
        ];
        
        const missingFeatures = requiredFeatures.filter((feature, index) => {
            const featureName = ['Promise', 'fetch', 'Map', 'Set', 'requestAnimationFrame'][index];
            if (!eval(feature)) {
                console.error(`Missing required feature: ${featureName}`);
                return true;
            }
            return false;
        });
        
        if (missingFeatures.length > 0) {
            showNotification('Your browser is missing required features. Please use a modern browser.', 'error', 0);
            return;
        }
        
        initMap();
        loadData();
        
        setTimeout(() => testAppsScriptConnection(), 2000);
        
        const searchInput = document.getElementById('searchInput');
        const searchHint = document.getElementById('searchHint');
        if (searchInput) {
            // Setup autocomplete for search
            setupAutocomplete(searchInput, searchHint);
            
            searchInput.addEventListener('input', debouncedUpdateMap);
            searchInput.addEventListener('search', debouncedUpdateMap);
        }
        
        document.getElementById('group1Btn')?.addEventListener('click', () => toggleGroupFilter(1));
        document.getElementById('group2Btn')?.addEventListener('click', () => toggleGroupFilter(2));
        document.getElementById('group3Btn')?.addEventListener('click', () => toggleGroupFilter(3));
        
        document.getElementById('selectionModeBtn')?.addEventListener('click', toggleSelectionMode);
        document.getElementById('clearSelectionBtn')?.addEventListener('click', clearSelection);
        document.getElementById('resetColorsBtn')?.addEventListener('click', resetColors);
        document.getElementById('showAllBtn')?.addEventListener('click', clearFilter);
        document.getElementById('panelToggle')?.addEventListener('click', togglePanel);
        document.getElementById('testConnectionBtn')?.addEventListener('click', testAppsScriptConnection);
        
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                if (state.selectionMode) {
                    toggleSelectionMode();
                } else if (state.selectedMarker) {
                    state.selectedMarker = null;
                    state.selectedRow = null;
                    updateMap();
                    const detailsContent = document.getElementById('detailsContent');
                    if (detailsContent) {
                        detailsContent.innerHTML = '<div class="no-selection">Click a marker to edit</div>';
                    }
                }
            }
            
            if ((e.ctrlKey || e.metaKey) && e.key === 'f') {
                e.preventDefault();
                const searchInput = document.getElementById('searchInput');
                if (searchInput) {
                    searchInput.focus();
                    searchInput.select();
                }
            }
        });
        
        console.log('Application initialized successfully');
        console.log('v2.7 - With Color Persistence (localStorage)');
        console.log('Ghost text shows suggestion, TAB accepts it');
        console.log('Driver colors are now saved locally!');
        
    } catch (error) {
        console.error('Error during application initialization:', error);
        showNotification('Failed to initialize application', 'error', 0);
    }
}

// Global functions
window.filterByCategory = filterByCategory;
window.clearSelection = clearSelection;
window.saveDriverName = saveDriverName;
window.saveMarkerData = saveMarkerData;
window.cancelEdit = cancelEdit;
window.bulkUpdateSelected = bulkUpdateSelected;
window.testAppsScriptConnection = testAppsScriptConnection;

window.addEventListener('error', function(event) {
    console.error('Global error:', event.error);
    console.error('Stack:', event.error?.stack);
    
    if (event.error?.message?.includes('group') || event.error?.message?.includes('Group')) {
        console.log('Group parsing tip: Supported business codes are DD, SUB, AA, F');
        console.log('Valid patterns: 1, 2, 3, 1DD1, 2F2, 1&2, 1DD&2, 123, 1SUB23, etc.');
    }
});

document.addEventListener('DOMContentLoaded', initializeApp);

console.log('Dog Walking Map v2.7 - With Color Persistence Ready');
    </script>
</body>
</html>
