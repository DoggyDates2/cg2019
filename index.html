<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üêï Dog Walking Map v2.7 - With Autocomplete</title>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <!-- Leaflet Draw CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css" />
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
            width: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: #f8f9fa;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .controls {
            background: white;
            padding: 15px 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
            min-height: 60px;
            z-index: 1000;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .control-group label {
            font-weight: 600;
            color: #333;
            white-space: nowrap;
        }

        input[type="text"] {
            padding: 6px 10px;
            border: 2px solid #e1e5e9;
            border-radius: 6px;
            font-size: 14px;
            transition: border-color 0.2s;
            background: white;
            width: 200px;
        }

        input[type="text"]:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .group-filters {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .group-filter-btn {
            padding: 6px 12px;
            border: 2px solid #e1e5e9;
            border-radius: 6px;
            background: white;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s;
            font-size: 14px;
            user-select: none;
        }

        .group-filter-btn:hover:not(:disabled) {
            border-color: #667eea;
            transform: translateY(-1px);
        }

        .group-filter-btn.active {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }

        .selection-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            border-left: 2px solid #e1e5e9;
            padding-left: 20px;
        }

        .main-content {
            display: flex;
            flex: 1;
            overflow: hidden;
            position: relative;
            height: calc(100vh - 80px);
        }

        .left-panel {
            width: 300px;
            background: white;
            border-right: 2px solid #e1e5e9;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            z-index: 999;
            transition: transform 0.3s ease;
        }

        .panel-toggle {
            display: none;
            position: absolute;
            left: 300px;
            top: 50%;
            transform: translateY(-50%);
            background: white;
            border: 2px solid #e1e5e9;
            border-left: none;
            padding: 10px 5px;
            cursor: pointer;
            z-index: 1000;
            border-radius: 0 5px 5px 0;
        }

        @media (max-width: 768px) {
            .left-panel {
                position: absolute;
                left: 0;
                top: 0;
                bottom: 0;
                transform: translateX(-100%);
                box-shadow: 2px 0 5px rgba(0,0,0,0.1);
            }
            
            .left-panel.open {
                transform: translateX(0);
            }
            
            .panel-toggle {
                display: block;
                left: 0;
            }
            
            .left-panel.open ~ .panel-toggle {
                left: 300px;
            }
        }

        .legend-section {
            border-bottom: 1px solid #e1e5e9;
            padding: 8px;
            overflow-y: auto;
            flex: 1;
            scrollbar-width: thin;
            scrollbar-color: #ccc #f8f9fa;
        }

        .legend-section::-webkit-scrollbar {
            width: 6px;
        }

        .legend-section::-webkit-scrollbar-track {
            background: #f8f9fa;
        }

        .legend-section::-webkit-scrollbar-thumb {
            background: #ccc;
            border-radius: 3px;
        }

        .legend h3 {
            margin-bottom: 8px;
            color: #333;
            font-size: 15px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 1px;
            font-size: 12px;
            cursor: pointer;
            padding: 2px 4px;
            border-radius: 3px;
            transition: all 0.2s;
            border: 1px solid transparent;
            user-select: none;
        }

        .legend-item:hover {
            background-color: #f8f9fa;
            border-color: #dee2e6;
            transform: translateX(2px);
        }

        .legend-item.active {
            background-color: #e3f2fd;
            border-color: #2196F3;
            font-weight: bold;
        }

        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 6px;
            border: 2px solid #333;
            flex-shrink: 0;
        }

        .legend-text {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .color-picker {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            border: 1px solid #333;
            margin-left: 6px;
            cursor: pointer;
            flex-shrink: 0;
            padding: 0;
            background: none;
            opacity: 0.7;
            transition: opacity 0.2s;
        }

        .color-picker:hover {
            opacity: 1;
        }

        .color-picker::-webkit-color-swatch-wrapper {
            padding: 0;
            border-radius: 50%;
        }

        .color-picker::-webkit-color-swatch {
            border: none;
            border-radius: 50%;
        }

        .edit-section {
            padding: 8px;
            padding-bottom: 20px;
            overflow-y: auto;
            flex-shrink: 0;
            min-height: 180px;
            max-height: 280px;
            border-top: 1px solid #e1e5e9;
        }

        .no-selection {
            text-align: center;
            color: #6c757d;
            font-style: italic;
            margin-top: 5px;
            padding: 0 5px;
            font-size: 11px;
        }

        .btn {
            padding: 8px 12px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s;
            font-size: 14px;
            margin: 2px;
            user-select: none;
            display: inline-flex;
            align-items: center;
            gap: 4px;
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .btn:not(:disabled):hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .btn-primary {
            background: #667eea;
            color: white;
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-clear {
            background: #28a745;
            color: white;
        }

        .btn-danger {
            background: #dc3545;
            color: white;
        }

        .btn-warning {
            background: #ffc107;
            color: #212529;
        }

        .btn-info {
            background: #17a2b8;
            color: white;
        }

        .selection-mode-active {
            background: #fff3cd !important;
            border-color: #ffc107 !important;
            color: #856404 !important;
        }

        .map-container {
            flex: 1;
            position: relative;
            background: #f0f0f0;
        }

        #map {
            width: 100%;
            height: 100%;
            background: #f0f0f0;
        }

        .leaflet-tile-pane {
            opacity: 1;
        }

        .leaflet-marker-pane {
            opacity: 1 !important;
            filter: none !important;
        }

        .bulk-edit-panel {
            background: #f8f9fa;
            border: 2px solid #007bff;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 10px;
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .bulk-edit-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .bulk-edit-header h4 {
            color: #007bff;
            margin: 0;
        }

        .selected-count {
            background: #007bff;
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
        }

        .bulk-edit-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }

        .bulk-edit-input {
            flex: 1;
            min-width: 150px;
            padding: 8px;
            border: 2px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }

        .bulk-edit-input:focus {
            outline: none;
            border-color: #007bff;
            box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.1);
        }

        .selected-dogs-preview {
            max-height: 120px;
            overflow-y: auto;
            background: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 8px;
            margin: 10px 0;
            font-size: 12px;
        }

        .selected-dog-item {
            padding: 2px 0;
            border-bottom: 1px solid #eee;
        }

        .selected-dog-item:last-child {
            border-bottom: none;
        }

        .marker-selected {
            filter: drop-shadow(0 0 10px #007bff) brightness(1.2);
            transform: scale(1.2);
        }

        .spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid rgba(0,0,0,.1);
            border-radius: 50%;
            border-top-color: #333;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 12px 20px;
            border-radius: 4px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            z-index: 9999;
            animation: slideInRight 0.3s ease;
            max-width: 350px;
        }

        @keyframes slideInRight {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes fadeOut {
            from { opacity: 1; }
            to { opacity: 0; }
        }

        .notification-error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .notification-success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .notification-info {
            background: #cfe2ff;
            color: #084298;
            border: 1px solid #b6d4fe;
        }

        .save-indicator {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: white;
            padding: 10px 15px;
            border-radius: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            display: none;
            align-items: center;
            gap: 8px;
            z-index: 1000;
            font-size: 14px;
        }

        .save-indicator.saving {
            background: #fff3cd;
            color: #856404;
        }

        .save-indicator.saved {
            background: #d4edda;
            color: #155724;
        }

        .save-indicator.error {
            background: #f8d7da;
            color: #721c24;
        }

        .custom-tooltip {
            background: rgba(0, 0, 0, 0.9) !important;
            border: 1px solid #333 !important;
            color: white !important;
            font-weight: 600 !important;
            font-size: 16px !important;
            padding: 8px 12px !important;
            border-radius: 4px !important;
            box-shadow: 0 2px 5px rgba(0,0,0,0.4) !important;
            white-space: normal !important;
            max-width: 250px !important;
            text-align: center !important;
            line-height: 1.4 !important;
        }
        
        .leaflet-tooltip-top:before {
            border-top-color: rgba(0, 0, 0, 0.9) !important;
        }

        .connection-status {
            position: fixed;
            bottom: 20px;
            left: 20px;
            padding: 8px 12px;
            border-radius: 20px;
            font-size: 12px;
            background: white;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            display: none;
            align-items: center;
            gap: 6px;
            z-index: 1000;
        }

        .connection-status.connected {
            background: #d4edda;
            color: #155724;
        }

        .connection-status.disconnected {
            background: #f8d7da;
            color: #721c24;
        }

        .error-message {
            color: #dc3545;
            font-style: italic;
            padding: 10px;
            text-align: center;
        }

        .version-indicator {
            margin-left: auto;
            padding: 0 10px;
            color: #666;
            font-size: 11px;
        }

        /* Autocomplete dropdown styling */
        input[list]::-webkit-calendar-picker-indicator {
            display: none !important;
        }

        input[list]:focus::-webkit-list-button {
            display: none;
        }

        /* Make autocomplete dropdown more visible */
        input[list] {
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%23666' d='M6 9L1 4h10z'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 8px center;
            padding-right: 25px !important;
        }
    </style>
</head>
<body>
    <div class="controls">
        <div class="control-group">
            <label for="searchInput">Search:</label>
            <input type="text" id="searchInput" placeholder="Search dogs, drivers, or addresses..." autocomplete="off" />
        </div>

        <div class="control-group group-filters">
            <button class="group-filter-btn active" data-group="1" id="group1Btn">Group 1 ‚≠ï</button>
            <button class="group-filter-btn active" data-group="2" id="group2Btn">Group 2 ‚ñ≤</button>
            <button class="group-filter-btn active" data-group="3" id="group3Btn">Group 3 ‚ñ†</button>
        </div>

        <div class="selection-controls">
            <button class="btn btn-warning" id="selectionModeBtn">üéØ Select Mode</button>
            <button class="btn btn-danger" id="clearSelectionBtn" style="display: none;">‚úñÔ∏è Clear Selection</button>
        </div>

        <div class="control-group">
            <button class="btn btn-secondary" id="resetColorsBtn">üé® Reset Colors</button>
            <button class="btn btn-info" id="testConnectionBtn">üîå Test Connection</button>
        </div>
        
        <div class="version-indicator">
            v2.7 - With Autocomplete
        </div>
    </div>

    <div class="main-content">
        <div class="left-panel" id="leftPanel">
            <div class="legend-section">
                <div style="text-align: center; margin-bottom: 6px;">
                    <button class="btn btn-clear" id="showAllBtn" style="width: 100%; padding: 6px 8px; font-size: 12px;">Show All</button>
                </div>
                
                <h3>Drivers</h3>
                <div id="legendContent">Loading...</div>
            </div>
            
            <div class="edit-section">
                <div id="bulkEditPanel" style="display: none;"></div>
                <div id="detailsContent" class="no-selection">
                    Click a marker to edit
                </div>
            </div>
        </div>
        
        <button class="panel-toggle" id="panelToggle">
            <span id="panelToggleIcon">‚óÄ</span>
        </button>

        <div class="map-container">
            <div id="map"></div>
        </div>
    </div>

    <div id="saveIndicator" class="save-indicator" style="display: none;">
        <span class="spinner"></span>
        <span>Saving...</span>
    </div>

    <div id="connectionStatus" class="connection-status" style="display: none;">
        <span>Sheet Connection</span>
    </div>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <!-- Leaflet Draw JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>
    
    <script>
        'use strict';

        // ==================== CONFIGURATION ====================
        const CONFIG = Object.freeze({
            SHEET_ID: '17QMFeALjTRJZdMAn9fJPgeh7meL80scQ1KipKJ4jz2A',
            WORKSHEET_NAME: 'Mymap',
            API_KEY: 'AIzaSyAGLteYp1k98SZo0FMClRgBX0LBsgpMxqI',
            APPS_SCRIPT_URL: 'https://script.google.com/macros/s/AKfycbx8j56q2vKpgm2jZu-bL3SxyySZccBK6F8XK-LinPmzHxEJDFh-aY-wIO6gVPfX8NH0dQ/exec',
            DEFAULT_LAT: 42.2968,
            DEFAULT_LNG: -71.2636,
            DEFAULT_ZOOM: 11,
            DEBOUNCE_DELAY: 300,
            MAX_MARKERS: 10000,
            MAX_SELECTION: 500
        });

        // Master color palette
        const ALL_COLORS = Object.freeze([
            '#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b', '#e377c2', '#7f7f7f',
            '#bcbd22', '#17becf', '#ff9896', '#98df8a', '#c5b0d5', '#c49c94', '#f7b6d3', '#c7c7c7',
            '#FFD700', '#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FECA57', '#FF9FF3', '#54A0FF',
            '#5F27CD', '#00D2D3', '#FF9F43', '#10AC84', '#EE5A24', '#0097E6', '#8C7AE6', '#F79F1F',
            '#A3CB38', '#E74C3C', '#3742FA', '#2F3542', '#FF3838', '#2ECC71', '#9B59B6', '#E67E22',
            '#1ABC9C', '#34495E', '#F39C12', '#E91E63', '#00BCD4', '#607D8B', '#795548', '#009688',
            '#FF5722', '#673AB7', '#3F51B5', '#2196F3', '#03DAC6', '#6200EA', '#FF4081', '#FFAB00',
            '#00E676', '#DD2C00', '#651FFF', '#FF6D00', '#FF1744', '#00E5FF', '#BF360C', '#1B5E20'
        ]);

        // ==================== STATE MANAGEMENT ====================
        const state = {
            map: null,
            markers: [],
            markerLookup: new Map(),
            coordinateLookup: new Map(),
            allData: [],
            filteredData: [],
            colorMap: {},
            selectedMarker: null,
            selectedRow: null,
            currentFilter: null,
            driverColorMap: {},
            customColors: {},
            activeGroups: [1, 2, 3],
            selectionMode: false,
            selectedMarkers: new Set(),
            drawControl: null,
            drawnItems: null,
            isUpdating: false,
            pendingSaves: new Map(),
            saveQueue: [],
            isSaving: false,
            driverCounts: {}
        };

        // ==================== UTILITY FUNCTIONS ====================
        function showNotification(message, type = 'info', duration = 3000) {
            const existing = document.querySelector('.notification');
            if (existing) {
                existing.remove();
            }
            
            const notification = document.createElement('div');
            notification.className = `notification notification-${type}`;
            notification.textContent = message;
            document.body.appendChild(notification);
            
            if (duration > 0) {
                setTimeout(() => {
                    notification.style.animation = 'fadeOut 0.3s ease';
                    setTimeout(() => {
                        if (notification.parentNode) {
                            notification.remove();
                        }
                    }, 300);
                }, duration);
            }
        }

        function debounce(func, wait) {
            let timeout;
            return function(...args) {
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(this, args), wait);
            };
        }

        function escapeHtml(text) {
            if (text == null) return '';
            const div = document.createElement('div');
            div.textContent = String(text);
            return div.innerHTML;
        }

        function validateCoordinates(lat, lng) {
            const latNum = Number(lat);
            const lngNum = Number(lng);
            
            if (!Number.isFinite(latNum) || !Number.isFinite(lngNum)) {
                return false;
            }
            
            if (latNum < -90 || latNum > 90 || lngNum < -180 || lngNum > 180) {
                return false;
            }
            
            if (Math.abs(latNum) < 0.0001 && Math.abs(lngNum) < 0.0001) {
                return false;
            }
            
            return true;
        }

        // Parse group from the Group column
        function parseGroup(groupValue) {
            if (!groupValue) return null;
            
            const originalValue = String(groupValue).trim();
            let strValue = originalValue;
            if (!strValue) return null;
            
            // Remove business codes
            if (strValue.includes('&')) {
                const parts = strValue.split('&').map(part => {
                    return part.replace(/DD|SUB|AA|Trial|F|XX/g, '').trim();
                });
                strValue = parts.join('&');
            } else {
                strValue = strValue.replace(/(\d)(DD|SUB|Trial|AA|F|XX)(\d)/g, '$1$3');
                strValue = strValue.replace(/(\d)(DD|Trial|SUB|AA|F|XX)$/g, '$1');
            }
            
            if (strValue !== originalValue && originalValue.match(/DD|Trial|SUB|AA|F/)) {
                console.log(`Business code parsed: "${originalValue}" -> "${strValue}"`);
            }
            
            if (strValue.match(/^([123])\1$/)) {
                return parseInt(strValue[0], 10);
            }
            
            if (strValue.includes('&')) {
                const groups = strValue.split('&')
                    .map(g => g.trim())
                    .filter(g => g.match(/^[123]$/))
                    .sort();
                if (groups.length === 2) {
                    const joined = groups.join('');
                    if (joined === '12' || joined === '23') {
                        return joined;
                    }
                    if (joined === '13') {
                        return '123';
                    }
                } else if (groups.length === 1) {
                    return parseInt(groups[0], 10);
                }
            }
            
            if (strValue.match(/^[123]{2,3}$/)) {
                const uniqueGroups = [...new Set(strValue.split(''))].sort().join('');
                if (uniqueGroups === '13') {
                    return '123';
                }
                return uniqueGroups;
            }
            
            if (strValue.match(/^[123]$/)) {
                return parseInt(strValue, 10);
            }
            
            return null;
        }

        function getDogId(row) {
            if (!row) return null;
            
            if (row['_uniqueId']) {
                return row['_uniqueId'];
            }
            
            let id = null;
            
            if (row['Dog ID'] && row['Dog ID'].trim()) {
                id = row['Dog ID'].trim();
            } else if (row['Dog Name'] && row['Dog Name'].trim()) {
                id = row['Dog Name'].trim();
                const index = row['_rowIndex'] ?? state.allData.indexOf(row);
                if (index >= 0) {
                    id = `${id}_${index}`;
                }
            } else {
                const index = row['_rowIndex'] ?? state.allData.indexOf(row);
                id = `dog_${index >= 0 ? index : Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
            }
            
            row['_uniqueId'] = id;
            return id;
        }

        function getSheetRowIndex(row) {
            if (row && typeof row['_rowIndex'] === 'number') {
                return row['_rowIndex'] + 2;
            }
            
            const index = state.allData.indexOf(row);
            if (index !== -1) {
                return index + 2;
            }
            
            console.error('Could not determine sheet row index for row:', row);
            return -1;
        }

        function isPointInPolygon(point, polygon) {
            if (!polygon || polygon.length < 3) return false;
            if (!point || !Number.isFinite(point.lat) || !Number.isFinite(point.lng)) return false;
            
            const x = point.lat, y = point.lng;
            let inside = false;
            
            for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                const xi = polygon[i].lat, yi = polygon[i].lng;
                const xj = polygon[j].lat, yj = polygon[j].lng;
                
                if (!Number.isFinite(xi) || !Number.isFinite(yi) || 
                    !Number.isFinite(xj) || !Number.isFinite(yj)) {
                    continue;
                }
                
                const intersect = ((yi > y) !== (yj > y)) &&
                    (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
                
                if (intersect) inside = !inside;
            }
            
            return inside;
        }

        // ==================== APPS SCRIPT COMMUNICATION ====================
        async function callAppsScript(payload) {
            try {
                const response = await fetch(CONFIG.APPS_SCRIPT_URL, {
                    method: 'POST',
                    mode: 'no-cors',
                    headers: {
                        'Content-Type': 'text/plain',
                    },
                    body: JSON.stringify(payload)
                });
                
                return { success: true };
                
            } catch (error) {
                console.error('Error calling Apps Script:', error);
                throw error;
            }
        }

        async function testAppsScriptConnection() {
            try {
                console.log('Testing Apps Script connection to:', CONFIG.APPS_SCRIPT_URL);
                
                const statusEl = document.getElementById('connectionStatus');
                if (statusEl) {
                    statusEl.style.display = 'flex';
                    statusEl.className = 'connection-status';
                    statusEl.innerHTML = '<span class="spinner"></span><span>Testing connection...</span>';
                }
                
                const response = await fetch(CONFIG.APPS_SCRIPT_URL);
                const text = await response.text();
                
                if (text.includes('Standalone Dog Walking Map Script')) {
                    showNotification('‚úÖ Google Sheets connection verified!', 'success');
                    console.log('Apps Script GET response:', text);
                    
                    if (statusEl) {
                        statusEl.className = 'connection-status connected';
                        statusEl.innerHTML = '‚úÖ Sheet Connected';
                        setTimeout(() => {
                            statusEl.style.display = 'none';
                        }, 3000);
                    }
                    
                    return true;
                } else {
                    showNotification('‚ö†Ô∏è Apps Script found but response unexpected', 'warning');
                    console.log('Unexpected response:', text);
                    
                    if (statusEl) {
                        statusEl.className = 'connection-status disconnected';
                        statusEl.innerHTML = '‚ö†Ô∏è Connection Issue';
                    }
                    
                    return false;
                }
            } catch (error) {
                console.error('Apps Script test failed:', error);
                showNotification('‚ö†Ô∏è Could not connect to Google Sheets', 'error');
                
                const statusEl = document.getElementById('connectionStatus');
                if (statusEl) {
                    statusEl.className = 'connection-status disconnected';
                    statusEl.innerHTML = '‚ùå Not Connected';
                }
                
                return false;
            }
        }

        // ==================== COLOR MANAGEMENT ====================
        function assignDriverColors() {
            if (!state.allData || state.allData.length === 0) {
                state.driverColorMap = {};
                return;
            }
            
            const drivers = new Set();
            
            state.allData.forEach(row => {
                if (row) {
                    const driverName = (row['Driver'] && row['Driver'].trim()) ? 
                                     row['Driver'].trim() : 
                                     (row['Combined'] ? row['Combined'].trim() : '');
                    if (driverName) {
                        drivers.add(driverName);
                    }
                }
            });
            
            const sortedDrivers = Array.from(drivers).sort();
            const newColorMap = {};
            
            sortedDrivers.forEach((driver, index) => {
                if (state.customColors[driver]) {
                    newColorMap[driver] = state.customColors[driver];
                } else if (state.driverColorMap[driver]) {
                    newColorMap[driver] = state.driverColorMap[driver];
                } else if (index < ALL_COLORS.length) {
                    newColorMap[driver] = ALL_COLORS[index];
                } else {
                    let hash = 0;
                    for (let i = 0; i < driver.length; i++) {
                        hash = ((hash << 5) - hash) + driver.charCodeAt(i);
                        hash = hash & hash;
                    }
                    const hue = Math.abs(hash) % 360;
                    newColorMap[driver] = `hsl(${hue}, 70%, 50%)`;
                }
            });
            
            state.driverColorMap = newColorMap;
            console.log('Assigned colors to', sortedDrivers.length, 'drivers');
        }

        function getDriverColor(name) {
            if (!name || name.trim() === '') return '#999999';
            const trimmedName = name.trim();
            
            if (trimmedName.toLowerCase().includes('unassigned')) {
                return '#000000';
            }
            
            if (state.customColors[trimmedName]) return state.customColors[trimmedName];
            return state.driverColorMap[trimmedName] || '#999999';
        }

        function changeCustomColor(categoryName, newColor) {
            console.log('Changing color for:', categoryName, 'to:', newColor);
            state.customColors[categoryName] = newColor;
            assignDriverColors();
            updateMap();
            showNotification(`Color updated for ${categoryName}`, 'success', 2000);
        }

        // ==================== AUTOCOMPLETE FUNCTIONS ====================
        function getUniqueDriverNames() {
            const drivers = new Set();
            
            state.allData.forEach(row => {
                if (row) {
                    const driverName = row['Driver']?.trim();
                    const combinedName = row['Combined']?.trim();
                    
                    if (driverName && driverName !== '') {
                        drivers.add(driverName);
                    }
                    if (combinedName && combinedName !== '' && combinedName !== driverName) {
                        drivers.add(combinedName);
                    }
                }
            });
            
            drivers.delete('');
            drivers.delete('unassigned');
            drivers.delete('Unassigned');
            
            return Array.from(drivers).sort((a, b) => a.toLowerCase().localeCompare(b.toLowerCase()));
        }

        function createDriverDatalist() {
            const existingDatalist = document.getElementById('driverNamesList');
            if (existingDatalist) {
                existingDatalist.remove();
            }
            
            const datalist = document.createElement('datalist');
            datalist.id = 'driverNamesList';
            
            const driverNames = getUniqueDriverNames();
            driverNames.forEach(name => {
                const option = document.createElement('option');
                option.value = name;
                datalist.appendChild(option);
            });
            
            document.body.appendChild(datalist);
            
            console.log(`Created autocomplete list with ${driverNames.length} driver names`);
            return driverNames.length;
        }

        // ==================== MARKER CREATION ====================
        function createMarkerIcon(color, isSelected = false, markerType = 'circle', group = null, isInSelection = false, dogName = null, hasCallout = false) {
            if (dogName) {
                const dogNameLower = dogName.toLowerCase();
                if (dogNameLower === 'park' || dogNameLower === 'field') {
                    const isPark = dogNameLower === 'park';
                    const strokeColor = isInSelection ? '#007bff' : (isSelected ? '#007bff' : '#666666');
                    const strokeWidth = isSelected ? 3 : (isInSelection ? 3 : 2);
                    const size = isInSelection ? 28 : 24;
                    const fillColor = isPark ? '#FFFFFF' : '#000000';
                    
                    return L.divIcon({
                        html: `<svg width="${size}" height="${size}" viewBox="0 0 ${size} ${size}" style="filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.3)); ${isInSelection ? 'animation: pulse 2s infinite;' : ''}">
                            <path d="M${size/2} 2 L${size-2} ${size/2} L${size/2} ${size-2} L2 ${size/2} Z" 
                                  fill="${fillColor}" stroke="${strokeColor}" stroke-width="${strokeWidth}"/>
                        </svg>`,
                        className: `custom-diamond-marker ${isInSelection ? 'marker-selected' : ''}`,
                        iconSize: [size, size],
                        iconAnchor: [size/2, size/2]
                    });
                }
            }
            
            color = color || '#999999';
            const strokeColor = hasCallout ? '#ff0000' : (isInSelection ? '#007bff' : (isSelected ? '#007bff' : '#000000'));
            const strokeWidth = isSelected ? 3 : (isInSelection ? 3 : 2);
            const size = isInSelection ? 16 : 13;
            
            let icon;
            
            try {
                if (group === 2) {
                    const svgSize = size + 3;
                    icon = L.divIcon({
                        html: `<svg width="${svgSize}" height="${svgSize}" viewBox="0 0 ${svgSize} ${svgSize}" style="filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.3)); ${isInSelection ? 'animation: pulse 2s infinite;' : ''}">
                            <path d="M${svgSize/2} 2 L${svgSize-2} ${svgSize-2} L2 ${svgSize-2} Z" 
                                  fill="${color}" stroke="${strokeColor}" stroke-width="${strokeWidth}"/>
                        </svg>`,
                        className: `custom-triangle-marker ${isInSelection ? 'marker-selected' : ''}`,
                        iconSize: [svgSize, svgSize],
                        iconAnchor: [svgSize/2, svgSize/2]
                    });
                } else if (group === 3) {
                    icon = L.divIcon({
                        html: `<div style="width: ${size}px; height: ${size}px; background-color: ${color}; border: ${strokeWidth}px solid ${strokeColor}; box-shadow: 0 2px 4px rgba(0,0,0,0.3); ${isInSelection ? 'animation: pulse 2s infinite;' : ''}"></div>`,
                        className: `custom-square-marker ${isInSelection ? 'marker-selected' : ''}`,
                        iconSize: [size, size],
                        iconAnchor: [size/2, size/2]
                    });
                } else if (group === '12') {
                    const svgSize = size + 4;
                    icon = L.divIcon({
                        html: `<svg width="${svgSize}" height="${svgSize}" viewBox="0 0 ${svgSize} ${svgSize}" style="filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.3)); ${isInSelection ? 'animation: pulse 2s infinite;' : ''}">
                            <polygon points="${svgSize/2},2 ${svgSize*0.6},${svgSize*0.4} ${svgSize-2},${svgSize*0.4} ${svgSize*0.7},${svgSize*0.6} ${svgSize*0.8},${svgSize-2} ${svgSize/2},${svgSize*0.75} ${svgSize*0.2},${svgSize-2} ${svgSize*0.3},${svgSize*0.6} 2,${svgSize*0.4} ${svgSize*0.4},${svgSize*0.4}" 
                                     fill="${color}" stroke="${strokeColor}" stroke-width="${strokeWidth}"/>
                        </svg>`,
                        className: `custom-star-marker ${isInSelection ? 'marker-selected' : ''}`,
                        iconSize: [svgSize, svgSize],
                        iconAnchor: [svgSize/2, svgSize/2]
                    });
                } else if (group === '23') {
                    const svgSize = size + 4;
                    icon = L.divIcon({
                        html: `<svg width="${svgSize}" height="${svgSize}" viewBox="0 0 ${svgSize} ${svgSize}" style="filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.3)); ${isInSelection ? 'animation: pulse 2s infinite;' : ''}">
                            <path d="M3 2 L${svgSize-3} 2 L${svgSize-5} ${svgSize-2} L5 ${svgSize-2} Z" 
                                  fill="${color}" stroke="${strokeColor}" stroke-width="${strokeWidth}"/>
                        </svg>`,
                        className: `custom-trapezoid-marker ${isInSelection ? 'marker-selected' : ''}`,
                        iconSize: [svgSize, svgSize],
                        iconAnchor: [svgSize/2, svgSize/2]
                    });
                } else if (group === '123') {
                    const svgSize = size + 4;
                    const cx = svgSize/2;
                    const cy = svgSize/2;
                    const r = (svgSize-4)/2;
                    icon = L.divIcon({
                        html: `<svg width="${svgSize}" height="${svgSize}" viewBox="0 0 ${svgSize} ${svgSize}" style="filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.3)); ${isInSelection ? 'animation: pulse 2s infinite;' : ''}">
                            <polygon points="${cx+r},${cy} ${cx+r/2},${cy-r*0.866} ${cx-r/2},${cy-r*0.866} ${cx-r},${cy} ${cx-r/2},${cy+r*0.866} ${cx+r/2},${cy+r*0.866}" 
                                     fill="${color}" stroke="${strokeColor}" stroke-width="${strokeWidth}"/>
                        </svg>`,
                        className: `custom-hexagon-marker ${isInSelection ? 'marker-selected' : ''}`,
                        iconSize: [svgSize, svgSize],
                        iconAnchor: [svgSize/2, svgSize/2]
                    });
                } else {
                    icon = L.divIcon({
                        html: `<div style="width: ${size}px; height: ${size}px; background-color: ${color}; border: ${strokeWidth}px solid ${strokeColor}; border-radius: 50%; box-shadow: 0 2px 4px rgba(0,0,0,0.3); ${isInSelection ? 'animation: pulse 2s infinite;' : ''}"></div>`,
                        className: `custom-marker ${isInSelection ? 'marker-selected' : ''}`,
                        iconSize: [size, size],
                        iconAnchor: [size/2, size/2]
                    });
                }
                
                return icon;
                
            } catch (error) {
                console.error('Error creating marker icon:', error);
                return L.divIcon({
                    html: `<div style="width: 13px; height: 13px; background-color: #999999; border: 2px solid #000000; border-radius: 50%;"></div>`,
                    className: 'custom-marker-fallback',
                    iconSize: [16, 16],
                    iconAnchor: [8, 8]
                });
            }
        }

        // ==================== MAP INITIALIZATION ====================
        function initMap() {
            try {
                console.log('Initializing map...');
                
                if (typeof L === 'undefined') {
                    throw new Error('Leaflet library not loaded');
                }
                
                state.map = L.map('map', {
                    center: [CONFIG.DEFAULT_LAT, CONFIG.DEFAULT_LNG],
                    zoom: CONFIG.DEFAULT_ZOOM,
                    preferCanvas: true,
                    zoomControl: true,
                    attributionControl: true
                });
                
                const tileUrl = 'https://stamen-tiles.a.ssl.fastly.net/toner/{z}/{x}/{y}.png';
                
                console.log('Loading map tiles: Stamen Toner (High contrast for clear streets)');
                
                const tileLayer = L.tileLayer(tileUrl, {
                    attribution: 'Map tiles by Stamen Design, under CC BY 3.0. Data by OpenStreetMap, under ODbL.',
                    maxZoom: 19,
                    minZoom: 2,
                    errorTileUrl: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII='
                });
                
                let fallbackLayer = null;
                let tileLoadTimeout = null;
                
                tileLoadTimeout = setTimeout(() => {
                    const tiles = document.querySelectorAll('.leaflet-tile');
                    if (tiles.length === 0 && !fallbackLayer) {
                        console.warn('No tiles loaded - switching to fallback');
                        showNotification('Stamen server not responding, trying fallback...', 'info');
                        
                        fallbackLayer = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png', {
                            attribution: '¬© OpenStreetMap contributors ¬© CARTO',
                            maxZoom: 19
                        });
                        state.map.removeLayer(tileLayer);
                        fallbackLayer.addTo(state.map);
                    }
                }, 5000);
                
                tileLayer.on('tileerror', function(error) {
                    console.error('Tile load error:', error);
                    if (tileLoadTimeout) {
                        clearTimeout(tileLoadTimeout);
                        tileLoadTimeout = null;
                    }
                    
                    if (!fallbackLayer) {
                        console.log('Switching to fallback map provider (CartoDB Positron)...');
                        fallbackLayer = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png', {
                            attribution: '¬© OpenStreetMap contributors ¬© CARTO',
                            maxZoom: 19
                        });
                        state.map.removeLayer(tileLayer);
                        fallbackLayer.addTo(state.map);
                        showNotification('Using fallback map tiles', 'info');
                    }
                });
                
                tileLayer.on('tileload', function() {
                    if (tileLoadTimeout) {
                        clearTimeout(tileLoadTimeout);
                        tileLoadTimeout = null;
                    }
                });
                
                tileLayer.addTo(state.map);
                
                setTimeout(() => {
                    const tiles = document.querySelectorAll('.leaflet-tile');
                    const loadedTiles = document.querySelectorAll('.leaflet-tile-loaded');
                    if (tiles.length === 0) {
                        console.warn('No tiles found - map provider may be down');
                        console.warn('Current tile URL pattern:', tileUrl);
                        showNotification('Map tiles not loading - check console for details', 'error');
                    } else {
                        console.log(`Map tiles status: ${tiles.length} total, ${loadedTiles.length} loaded`);
                        if (loadedTiles.length === 0) {
                            console.warn('Tiles found but none loaded - possible network issue');
                        }
                    }
                }, 3000);
                
                state.map.on('error', function(e) {
                    console.error('Map error:', e);
                });

                console.log('Map initialized successfully');
                
            } catch (error) {
                console.error('Error initializing map:', error);
                showNotification('Failed to initialize map. Please refresh the page.', 'error', 0);
            }
        }

        // ==================== DATA LOADING ====================
        async function loadData() {
            showNotification('Loading data from Google Sheets...', 'info');
            
            try {
                if (!CONFIG.SHEET_ID || !CONFIG.API_KEY) {
                    throw new Error('Sheet ID or API key not configured');
                }
                
                const url = `https://sheets.googleapis.com/v4/spreadsheets/${CONFIG.SHEET_ID}/values/${CONFIG.WORKSHEET_NAME}?key=${CONFIG.API_KEY}`;
                
                console.log(`Loading data from sheet: "${CONFIG.WORKSHEET_NAME}"`);
                
                const response = await fetch(url);
                
                if (!response.ok) {
                    if (response.status === 403) {
                        throw new Error('Access denied - check API key permissions');
                    } else if (response.status === 404) {
                        throw new Error(`Sheet not found - verify worksheet name "${CONFIG.WORKSHEET_NAME}"`);
                    } else {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                }
                
                const data = await response.json();
                
                if (!data || !data.values || data.values.length < 2) {
                    throw new Error('No data found in sheet');
                }
                
                const headers = data.values[0];
                const rows = data.values.slice(1);
                
                console.log('Headers from Google Sheet:', headers);
                
                const requiredColumns = ['Dog Name', 'Latitude', 'Longitude', 'Group'];
                const missingColumns = requiredColumns.filter(col => !headers.includes(col));
                
                if (missingColumns.length > 0) {
                    console.warn(`Missing columns: ${missingColumns.join(', ')}`);
                }
                
                const processedData = [];
                let validRows = 0;
                const invalidRows = [];
                
                rows.forEach((row, index) => {
                    try {
                        const obj = {};
                        headers.forEach((header, headerIndex) => {
                            obj[header] = row[headerIndex] || '';
                        });
                        
                        if (!obj['Dog Name'] || obj['Dog Name'].trim() === '') {
                            invalidRows.push(index + 2);
                            return;
                        }
                        
                        const lat = parseFloat(obj['Latitude']);
                        const lng = parseFloat(obj['Longitude']);
                        
                        if (!validateCoordinates(lat, lng)) {
                            invalidRows.push(index + 2);
                            return;
                        }
                        
                        obj['_lat'] = lat;
                        obj['_lng'] = lng;
                        obj['_rowIndex'] = index;
                        
                        processedData.push(obj);
                        validRows++;
                        
                    } catch (rowError) {
                        console.warn(`Error processing row ${index + 2}:`, rowError);
                        invalidRows.push(index + 2);
                    }
                });
                
                if (validRows === 0) {
                    throw new Error('No valid data rows found');
                }
                
                state.allData = processedData;
                state.markerLookup.clear();
                state.coordinateLookup.clear();
                
                let message = `Loaded ${validRows} locations`;
                if (invalidRows.length > 0) {
                    const showRows = invalidRows.slice(0, 5);
                    const moreText = invalidRows.length > 5 ? ` and ${invalidRows.length - 5} more` : '';
                    message += ` (Invalid rows: ${showRows.join(', ')}${moreText})`;
                }
                showNotification(message, 'success');
                
                assignDriverColors();
                createDriverDatalist();  // Create autocomplete list
                updateMap();
                
            } catch (error) {
                console.error('Data loading error:', error);
                showNotification('Error loading data: ' + error.message, 'error');
                
                state.allData = [];
                state.markers = [];
                state.filteredData = [];
                state.markerLookup.clear();
                state.coordinateLookup.clear();
            }
        }

        // ==================== MAP UPDATE ====================
        function updateMap() {
            try {
                console.log('UpdateMap called - using legend counts for tooltips');
                
                updateLegend();
                console.log('Driver counts after legend update:', state.driverCounts);
                
                state.markers.forEach(m => {
                    if (m && m.marker) {
                        try {
                            const getMethod = 'get' + 'Tooltip';
                            const unbindMethod = 'unbind' + 'Tooltip';
                            
                            if (m.marker[getMethod] && typeof m.marker[getMethod] === 'function') {
                                const tooltip = m.marker[getMethod]();
                                if (tooltip && m.marker[unbindMethod]) {
                                    m.marker[unbindMethod]();
                                }
                            }
                            
                            m.marker.off();
                            if (state.map.hasLayer(m.marker)) {
                                state.map.removeLayer(m.marker);
                            }
                        } catch (e) {
                            console.warn('Error removing marker:', e);
                        }
                    }
                });
                state.markers = [];
                state.coordinateLookup.clear();

                const searchInput = document.getElementById('searchInput');
                const searchTerm = searchInput ? searchInput.value.toLowerCase().trim() : '';

                if (!state.allData || state.allData.length === 0) {
                    updateLegend();
                    return;
                }

                state.filteredData = state.allData.filter(row => {
                    if (!row) return false;
                    
                    if (searchTerm) {
                        const searchFields = [
                            row['Dog Name'],
                            row['Address'],
                            row['Driver'],
                            row['Combined'],
                            row['Callout'],
                            row['Dog ID']
                        ].filter(Boolean).join(' ').toLowerCase();
                        
                        if (!searchFields.includes(searchTerm)) {
                            return false;
                        }
                    }
                    
                    const group = parseGroup(row['Group']);
                    if (group !== null) {
                        if (typeof group === 'string' && group.length > 1) {
                            const hasActiveGroup = group.split('').some(g => state.activeGroups.includes(parseInt(g)));
                            if (!hasActiveGroup) {
                                return false;
                            }
                        } else if (typeof group === 'number') {
                            if (!state.activeGroups.includes(group)) {
                                return false;
                            }
                        }
                    } else {
                        if (state.activeGroups.length < 3) {
                            return false;
                        }
                    }
                    
                    if (state.currentFilter !== null) {
                        const rowDriver = row['Driver'] || row['Combined'] || '';
                        if (rowDriver !== state.currentFilter) {
                            return false;
                        }
                    }
                    
                    return true;
                });

                state.colorMap = {};
                state.allData.forEach(row => {
                    if (row && (row['Driver'] || row['Combined'])) {
                        const driver = row['Driver'] || row['Combined'] || '';
                        if (driver) {
                            state.colorMap[driver] = getDriverColor(driver);
                        }
                    }
                });

                state.filteredData.forEach(row => {
                    if (!row) return;
                    
                    try {
                        const lat = row['_lat'] ?? parseFloat(row['Latitude']);
                        const lng = row['_lng'] ?? parseFloat(row['Longitude']);
                        
                        if (!validateCoordinates(lat, lng)) return;
                        
                        const coordKey = `${lat.toFixed(6)},${lng.toFixed(6)}`;
                        const existingCount = state.coordinateLookup.get(coordKey) || 0;
                        state.coordinateLookup.set(coordKey, existingCount + 1);
                        
                        const offsetLat = existingCount > 0 ? lat + (existingCount * 0.00001) : lat;
                        const offsetLng = existingCount > 0 ? lng + (existingCount * 0.00001) : lng;

                        const driver = row['Driver'] || row['Combined'] || '';
                        let color = state.colorMap[driver] || '#999999';
                        
                        if (driver.toLowerCase().includes('unassigned')) {
                            color = '#000000';
                        }
                        
                        const group = parseGroup(row['Group']);
                        const dogId = getDogId(row);
                        const isInSelection = dogId && state.selectedMarkers.has(dogId);
                        const hasCallout = row['Callout'] && row['Callout'].trim();
                        
                        const driverDisplay = driver || 'No Driver';
                        const groupDisplay = row['Group'] || '?';
                        const dogNameDisplay = row['Dog Name'] || 'Unknown';
                        const notesValue = row['Notes'] || '';
                        
                        let tooltipHtml = `<div style="text-align: center;"><strong>${escapeHtml(driverDisplay)}:${escapeHtml(groupDisplay)}</strong>`;
                        
                        if (driver && state.driverCounts && state.driverCounts[driver]) {
                            const counts = state.driverCounts[driver];
                            const total = counts[1] + counts[2] + counts[3];
                            if (total > 0) {
                                tooltipHtml += `  <span style="color: #ff6b6b; font-weight: bold;">(${counts[1]}, ${counts[2]}, ${counts[3]})</span>`;
                            }
                            if (state.markers.length < 3) {
                                console.log(`Tooltip for ${driver}: (${counts[1]}, ${counts[2]}, ${counts[3]})`);
                            }
                        }
                        
                        tooltipHtml += `<br/>${escapeHtml(dogNameDisplay)}`;
                        
                        if (notesValue && notesValue.toString().trim() !== '') {
                            tooltipHtml += `<br/><span style="font-style: italic; color: white;">${escapeHtml(notesValue)}</span>`;
                        }
                        
                        tooltipHtml += `</div>`;
                        
                        const marker = L.marker([offsetLat, offsetLng], {
                            icon: createMarkerIcon(color, false, 'group', group, isInSelection, row['Dog Name'], hasCallout),
                            riseOnHover: true
                        });

                        marker.addTo(state.map);
                        
                        const tooltipMethod = 'bind' + 'Tooltip';
                        if (typeof marker[tooltipMethod] === 'function') {
                            marker[tooltipMethod](tooltipHtml, {
                                permanent: false,
                                direction: 'top',
                                offset: [0, -15],
                                className: 'custom-tooltip',
                                opacity: 0.95
                            });
                        } else {
                            console.error('Method ' + tooltipMethod + ' not found on marker');
                            console.log('Available methods:', Object.getOwnPropertyNames(Object.getPrototypeOf(marker)).sort());
                        }

                        marker._rowData = row;
                        
                        const markerData = {marker, row, index: row['_rowIndex'] ?? state.allData.indexOf(row), group};
                        
                        if (dogId) {
                            state.markerLookup.set(dogId, markerData);
                        }
                        
                        marker.on('click', function(e) {
                            try {
                                if (state.selectionMode) {
                                    e.originalEvent.stopPropagation();
                                    const dogId = getDogId(row);
                                    if (!dogId) return;
                                    
                                    if (state.selectedMarkers.has(dogId)) {
                                        state.selectedMarkers.delete(dogId);
                                    } else if (state.selectedMarkers.size < CONFIG.MAX_SELECTION) {
                                        state.selectedMarkers.add(dogId);
                                    } else {
                                        showNotification(`Maximum ${CONFIG.MAX_SELECTION} markers can be selected`, 'error');
                                        return;
                                    }
                                    
                                    updateSelectedMarkersDisplay();
                                    updateBulkEditPanel();
                                } else {
                                    const validIndex = row['_rowIndex'] ?? state.allData.indexOf(row);
                                    selectMarker(marker, row, validIndex, group);
                                }
                            } catch (clickError) {
                                console.error('Error handling marker click:', clickError);
                                showNotification('Error handling marker click', 'error');
                            }
                        });

                        state.markers.push(markerData);
                        
                    } catch (markerError) {
                        console.warn('Error creating marker:', markerError);
                    }
                });

                if (state.markers.length > 0 && state.markers.length < 100) {
                    const group = L.featureGroup(state.markers.map(m => m.marker));
                    state.map.fitBounds(group.getBounds().pad(0.1));
                }
                
            } catch (error) {
                console.error('Error in updateMap:', error);
                showNotification('Error updating map display', 'error');
            }
        }

        // ==================== SELECTION MODE ====================
        function toggleSelectionMode() {
            state.selectionMode = !state.selectionMode;
            
            const btn = document.getElementById('selectionModeBtn');
            const clearBtn = document.getElementById('clearSelectionBtn');
            
            if (!btn || !clearBtn) return;
            
            if (state.selectionMode) {
                btn.textContent = 'üéØ Exit Select Mode';
                btn.classList.add('selection-mode-active');
                clearBtn.style.display = 'inline-block';
                
                enableDrawingTools();
                showNotification('Draw a polygon around markers to select them', 'info');
            } else {
                btn.textContent = 'üéØ Select Mode';
                btn.classList.remove('selection-mode-active');
                clearBtn.style.display = 'none';
                
                disableDrawingTools();
                clearSelection();
            }
        }

        function enableDrawingTools() {
            if (!state.map || !L.Control.Draw) {
                console.error('Leaflet.draw library not loaded');
                return;
            }
            
            try {
                if (!state.drawnItems) {
                    state.drawnItems = new L.FeatureGroup();
                    state.map.addLayer(state.drawnItems);
                }

                if (!state.drawControl) {
                    state.drawControl = new L.Control.Draw({
                        position: 'topleft',
                        edit: {
                            featureGroup: state.drawnItems,
                            remove: true,
                            edit: true
                        },
                        draw: {
                            polygon: {
                                allowIntersection: false,
                                drawError: {
                                    color: '#e1e100',
                                    message: '<strong>Error!</strong> Shape intersects itself!'
                                },
                                shapeOptions: {
                                    color: '#007bff',
                                    fillColor: '#007bff',
                                    fillOpacity: 0.2,
                                    weight: 3
                                },
                                showArea: true
                            },
                            rectangle: {
                                shapeOptions: {
                                    color: '#007bff',
                                    fillColor: '#007bff',
                                    fillOpacity: 0.2,
                                    weight: 3
                                }
                            },
                            circle: false,
                            marker: false,
                            circlemarker: false,
                            polyline: false
                        }
                    });
                    
                    state.map.addControl(state.drawControl);
                }

                state.map.off('draw:created').on('draw:created', onDrawCreated);
                state.map.off('draw:deleted').on('draw:deleted', onDrawDeleted);
                state.map.off('draw:edited').on('draw:edited', onDrawEdited);
                
            } catch (error) {
                console.error('Error enabling drawing tools:', error);
            }
        }

        function disableDrawingTools() {
            try {
                if (state.map) {
                    state.map.off('draw:created');
                    state.map.off('draw:deleted');
                    state.map.off('draw:edited');
                }

                if (state.drawControl && state.map && state.map.hasLayer(state.drawControl)) {
                    state.map.removeControl(state.drawControl);
                }
                state.drawControl = null;

                if (state.drawnItems) {
                    state.drawnItems.clearLayers();
                    if (state.map && state.map.hasLayer(state.drawnItems)) {
                        state.map.removeLayer(state.drawnItems);
                    }
                }
                state.drawnItems = null;

            } catch (error) {
                console.error('Error disabling drawing tools:', error);
            }
        }

        function onDrawCreated(e) {
            if (!state.selectionMode || !state.drawnItems) return;
            
            const layer = e.layer;
            if (!layer) return;
            
            try {
                state.drawnItems.addLayer(layer);
                
                selectMarkersInPolygonAdditive(layer);
                updateSelectedMarkersDisplay();
                updateBulkEditPanel();
                
                const shapeCount = state.drawnItems.getLayers().length;
                if (shapeCount > 10) {
                    showNotification('Maximum 10 selection areas allowed', 'error');
                    const layers = state.drawnItems.getLayers();
                    if (layers.length > 0) {
                        state.drawnItems.removeLayer(layers[0]);
                    }
                }
                
            } catch (error) {
                console.error('Error in onDrawCreated:', error);
            }
        }

        function onDrawDeleted(e) {
            if (!state.selectionMode || !state.drawnItems) return;
            
            try {
                state.selectedMarkers.clear();
                
                state.drawnItems.eachLayer(function(layer) {
                    if (layer) {
                        selectMarkersInPolygonAdditive(layer);
                    }
                });
                
                updateSelectedMarkersDisplay();
                updateBulkEditPanel();
            } catch (error) {
                console.error('Error in onDrawDeleted:', error);
            }
        }

        function onDrawEdited(e) {
            if (!state.selectionMode || !state.drawnItems) return;
            
            try {
                state.selectedMarkers.clear();
                
                state.drawnItems.eachLayer(function(layer) {
                    if (layer) {
                        selectMarkersInPolygonAdditive(layer);
                    }
                });
                
                updateSelectedMarkersDisplay();
                updateBulkEditPanel();
            } catch (error) {
                console.error('Error in onDrawEdited:', error);
            }
        }

        function selectMarkersInPolygonAdditive(polygon) {
            if (!state.selectionMode || !state.markers || state.markers.length === 0) return;
            
            const bounds = polygon.getBounds();
            
            state.markers.forEach(markerData => {
                if (!markerData || !markerData.marker || !markerData.row) return;
                
                const latLng = markerData.marker.getLatLng();
                if (!latLng) return;
                
                if (!bounds.contains(latLng)) return;
                
                let isInside = false;
                try {
                    if (polygon instanceof L.Polygon || polygon instanceof L.Rectangle) {
                        const latlngs = polygon.getLatLngs();
                        if (latlngs && latlngs.length > 0) {
                            const outerRing = Array.isArray(latlngs[0]) ? latlngs[0] : latlngs;
                            if (outerRing && outerRing.length >= 3) {
                                isInside = isPointInPolygon(latLng, outerRing);
                            }
                        }
                    }
                } catch (error) {
                    console.error('Error checking polygon intersection:', error);
                    return;
                }
                
                if (isInside) {
                    const dogId = getDogId(markerData.row);
                    if (dogId && state.selectedMarkers.size < CONFIG.MAX_SELECTION) {
                        state.selectedMarkers.add(dogId);
                    }
                }
            });
        }

        function updateSelectedMarkersDisplay() {
            if (!state.markers || state.markers.length === 0) return;
            
            state.markers.forEach(markerData => {
                if (!markerData || !markerData.marker || !markerData.row) return;
                
                try {
                    const dogId = getDogId(markerData.row);
                    const isInSelection = dogId && state.selectedMarkers.has(dogId);
                    const isSelected = state.selectedMarker === markerData.marker;
                    
                    const driver = markerData.row['Driver'] || markerData.row['Combined'] || '';
                    let color = state.colorMap[driver] || '#999999';
                    
                    if (driver.toLowerCase().includes('unassigned')) {
                        color = '#000000';
                    }
                    
                    const newIcon = createMarkerIcon(color, isSelected, 'group', markerData.group, isInSelection, markerData.row['Dog Name'], markerData.row['Callout'] && markerData.row['Callout'].trim());
                    markerData.marker.setIcon(newIcon);
                } catch (error) {
                    console.error('Error updating marker display:', error);
                }
            });
            
            if (state.selectionMode) {
                showNotification(`Selected ${state.selectedMarkers.size} markers`, 'info', 1000);
            }
        }

        function updateBulkEditPanel() {
            const panel = document.getElementById('bulkEditPanel');
            if (!panel) return;
            
            if (state.selectedMarkers.size === 0) {
                panel.style.display = 'none';
                return;
            }
            
            panel.style.display = 'block';
            
            try {
                createDriverDatalist();
                
                const selectedRows = [];
                for (const dogId of state.selectedMarkers) {
                    const markerData = state.markerLookup.get(dogId);
                    if (markerData && markerData.row) {
                        selectedRows.push(markerData.row);
                    }
                }
                
                const previewHtml = selectedRows.slice(0, 10).map(row => {
                    const dogName = escapeHtml(row['Dog Name'] || 'Unknown');
                    const driver = escapeHtml(row['Driver'] || row['Combined'] || 'No Driver');
                    return `<div class="selected-dog-item">${dogName} - ${driver}</div>`;
                }).join('');
                
                const moreText = selectedRows.length > 10 ? 
                    `<div class="selected-dog-item">... and ${selectedRows.length - 10} more</div>` : '';
                
                panel.innerHTML = `
                    <div class="bulk-edit-panel">
                        <div class="bulk-edit-header">
                            <h4>üéØ Bulk Edit Selection</h4>
                            <span class="selected-count">${state.selectedMarkers.size} selected</span>
                        </div>
                        <div class="selected-dogs-preview">
                            ${previewHtml}
                            ${moreText}
                        </div>
                        <div class="bulk-edit-controls">
                            <input type="text" 
                                   id="bulkDriverInput" 
                                   class="bulk-edit-input" 
                                   placeholder="New driver name"
                                   list="driverNamesList"
                                   autocomplete="off" />
                            <button class="btn btn-primary" onclick="bulkUpdateSelected()" 
                                    id="bulkUpdateBtn">üíæ Update All</button>
                            <button class="btn btn-secondary" onclick="clearSelection()">‚úñÔ∏è Cancel</button>
                        </div>
                    </div>
                `;
                
                setTimeout(() => {
                    const input = document.getElementById('bulkDriverInput');
                    if (input) input.focus();
                }, 100);
                
            } catch (error) {
                console.error('Error updating bulk edit panel:', error);
                panel.innerHTML = '<div class="error-message">Error loading selection panel</div>';
            }
        }

        function clearSelection() {
            state.selectedMarkers.clear();
            updateSelectedMarkersDisplay();
            updateBulkEditPanel();
            
            if (state.drawnItems) {
                state.drawnItems.clearLayers();
            }
            
            if (state.selectionMode) {
                showNotification('Selection cleared', 'info', 1000);
            }
        }

        // ==================== MARKER SELECTION ====================
        function selectMarker(marker, row, index, group) {
            if (!marker || !row || !state.map) {
                console.error('Invalid parameters for selectMarker');
                return;
            }
            
            try {
                if (state.selectedMarker && state.selectedMarker !== marker) {
                    const prevData = state.markers.find(m => m && m.marker === state.selectedMarker);
                    if (prevData) {
                        try {
                            const driver = prevData.row['Driver'] || prevData.row['Combined'] || '';
                            let color = state.colorMap[driver] || '#999999';
                            
                            if (driver.toLowerCase().includes('unassigned')) {
                                color = '#000000';
                            }
                            
                            const dogId = getDogId(prevData.row);
                            const isInSelection = dogId && state.selectedMarkers.has(dogId);
                            state.selectedMarker.setIcon(createMarkerIcon(color, false, 'group', prevData.group, isInSelection, prevData.row['Dog Name'], prevData.row['Callout'] && prevData.row['Callout'].trim()));
                        } catch (clearError) {
                            console.warn('Error clearing previous marker:', clearError);
                        }
                    }
                }

                state.selectedMarker = marker;
                state.selectedRow = row;
                
                try {
                    const driver = row['Driver'] || row['Combined'] || '';
                    let color = state.colorMap[driver] || '#999999';
                    
                    if (driver.toLowerCase().includes('unassigned')) {
                        color = '#000000';
                    }
                    
                    const dogId = getDogId(row);
                    const isInSelection = dogId && state.selectedMarkers.has(dogId);
                    marker.setIcon(createMarkerIcon(color, true, 'group', group, isInSelection, row['Dog Name'], row['Callout'] && row['Callout'].trim()));
                } catch (iconError) {
                    console.warn('Error updating marker icon:', iconError);
                }

                updateDetailsPanel(row, index);
                
            } catch (error) {
                console.error('Error in selectMarker:', error);
                showNotification('Error selecting marker', 'error');
            }
        }

        function updateDetailsPanel(row, index) {
            const detailsContent = document.getElementById('detailsContent');
            if (!detailsContent) return;
            
            try {
                createDriverDatalist();
                
                const actualIndex = row['_rowIndex'] ?? state.allData.indexOf(row);
                const driverName = row['Driver'] || '';
                const dogName = row['Dog Name'] || 'Unknown';
                const group = parseGroup(row['Group']);
                const groupText = row['Group'] || '';
                const address = row['Address'] || '';
                const capacity = row['Capacity'] || '';
                const callout = row['Callout'] || '';
                const dogId = row['Dog ID'] || '';
                
                let infoHtml = '';
                
                infoHtml += `<div style="font-weight: bold; color: #333; margin-bottom: 8px; font-size: 14px; text-align: center; padding: 6px 8px; background: #f8f9fa; border-radius: 4px;">
                    ${escapeHtml(dogName)}
                </div>`;
                
                infoHtml += `<div style="text-align: center; margin-bottom: 6px; font-size: 16px; font-weight: bold; color: #333;">
                    Group ${escapeHtml(groupText || '?')}
                </div>`;
                
                if (dogId) {
                    infoHtml += `<div style="margin-bottom: 6px; font-size: 11px; color: #999; text-align: center;">
                        ID: ${escapeHtml(dogId)}
                    </div>`;
                }
                
                if (address) {
                    infoHtml += `<div style="margin-bottom: 6px; font-size: 12px; color: #666;">
                        ${escapeHtml(address)}
                    </div>`;
                }
                
                if (capacity) {
                    infoHtml += `<div style="margin-bottom: 6px; font-size: 12px; color: #666;">
                        <strong>Capacity:</strong> ${escapeHtml(capacity)}
                    </div>`;
                }
                
                if (callout) {
                    infoHtml += `<div style="background: #fff3cd; padding: 6px; border-radius: 4px; margin-bottom: 6px;">
                        <strong style="color: #856404;">CALLOUT:</strong> 
                        <span style="color: #856404;">${escapeHtml(callout)}</span>
                    </div>`;
                }
                
                const detailsHtml = `
                    ${infoHtml}
                    
                    <div style="border-top: 1px solid #dee2e6; padding-top: 8px; margin-top: 8px;">
                        <label style="font-size: 12px; color: #666; font-weight: 600; display: block; margin-bottom: 4px;">Driver:</label>
                        <div style="margin-bottom: 8px;">
                            <input type="text" 
                                   id="editDriver" 
                                   value="${escapeHtml(driverName)}" 
                                   placeholder="Enter driver name"
                                   list="driverNamesList"
                                   style="width: 100%; padding: 6px 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px;"
                                   autocomplete="off">
                        </div>
                        
                        <label style="font-size: 12px; color: #666; font-weight: 600; display: block; margin-bottom: 4px;">Group:</label>
                        <div style="margin-bottom: 8px;">
                            <input type="text" id="editGroup" value="${escapeHtml(groupText)}" 
                                   placeholder="1, 2, 3, 1&2, 1DD1, 2SUB2, etc."
                                   title="Supports business codes: DD, SUB, Trial, AA, F, Trial, XX (e.g., 1DD1, 2F2, 1SUB&2)"
                                   style="width: 100%; padding: 6px 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px;"
                                   autocomplete="off">
                        </div>
                        
                        <div style="display: flex; gap: 4px;">
                            <button class="btn btn-primary" onclick="saveMarkerData()" 
                                    id="saveBtn" style="flex: 1; padding: 6px 8px; font-size: 12px;">
                                üíæ Save
                            </button>
                            <button class="btn btn-secondary" onclick="cancelEdit()" 
                                    style="flex: 1; padding: 6px 8px; font-size: 12px;">
                                ‚úñÔ∏è Cancel
                            </button>
                        </div>
                    </div>
                `;
                
                detailsContent.innerHTML = detailsHtml;
                
                setTimeout(() => {
                    const driverInput = document.getElementById('editDriver');
                    const groupInput = document.getElementById('editGroup');
                    
                    if (driverInput) {
                        driverInput.focus();
                        driverInput.select();
                        
                        driverInput.addEventListener('keydown', function(e) {
                            if (e.key === 'Enter') {
                                e.preventDefault();
                                saveMarkerData();
                            } else if (e.key === 'Escape') {
                                e.preventDefault();
                                cancelEdit();
                            }
                        });
                    }
                    
                    if (groupInput) {
                        groupInput.addEventListener('keydown', function(e) {
                            if (e.key === 'Enter') {
                                e.preventDefault();
                                saveMarkerData();
                            } else if (e.key === 'Escape') {
                                e.preventDefault();
                                cancelEdit();
                            }
                        });
                    }
                }, 100);
                
            } catch (error) {
                console.error('Error updating details panel:', error);
                detailsContent.innerHTML = '<div class="error-message">Error showing details</div>';
            }
        }

        // ==================== LEGEND ====================
        function updateLegend() {
            const legendContent = document.getElementById('legendContent');
            if (!legendContent) return;
            
            try {
                const sortedEntries = Object.entries(state.colorMap).sort(([a], [b]) => a.localeCompare(b));
                const legendItems = [];
                
                state.driverCounts = {};
                
                sortedEntries.forEach(([key, color]) => {
                    if (!key || !color) return;
                    
                    const isActive = state.currentFilter === key;
                    let displayText = escapeHtml(key);
                    
                    if (state.allData && state.allData.length > 0) {
                        const groupCounts = { 1: 0, 2: 0, 3: 0 };
                        
                        state.allData.forEach(row => {
                            if (!row) return;
                            const rowDriver = row['Driver'] || row['Combined'] || '';
                            if (rowDriver !== key) return;
                            
                            const dogCount = parseInt(row['Number of Dogs'] || '1') || 1;
                            const group = parseGroup(row['Group']);
                            
                            if (group !== null) {
                                if (typeof group === 'string' && group.length > 1) {
                                    group.split('').forEach(g => {
                                        const groupNum = parseInt(g);
                                        if (groupNum >= 1 && groupNum <= 3) {
                                            groupCounts[groupNum] += dogCount;
                                        }
                                    });
                                } else if (typeof group === 'number' && group >= 1 && group <= 3) {
                                    groupCounts[group] += dogCount;
                                }
                            }
                        });
                        
                        state.driverCounts[key] = groupCounts;
                        
                        const total = groupCounts[1] + groupCounts[2] + groupCounts[3];
                        if (total > 0) {
                            displayText += ` (${groupCounts[1]}, ${groupCounts[2]}, ${groupCounts[3]})`;
                        }
                    }
                    
                    const dataKey = escapeHtml(key);
                    const safeKey = key.replace(/'/g, "\\'").replace(/"/g, '\\"').replace(/\\/g, '\\\\');
                    
                    legendItems.push(`
                        <div class="legend-item ${isActive ? 'active' : ''}" 
                             onclick="filterByCategory('${safeKey}')"
                             role="button"
                             tabindex="0"
                             aria-label="Filter by ${dataKey}"
                             aria-pressed="${isActive}">
                            <div class="legend-color" style="background-color: ${color}"></div>
                            <span class="legend-text">${displayText}</span>
                            <input type="color" class="color-picker" value="${color}" 
                                   data-category="${dataKey}"
                                   aria-label="Change color for ${dataKey}"
                                   onclick="event.stopPropagation()" />
                        </div>
                    `);
                });
                
                legendContent.innerHTML = legendItems.join('') || '<div class="no-selection">No drivers found</div>';
                
                const pickers = legendContent.querySelectorAll('.color-picker');
                pickers.forEach(picker => {
                    picker.addEventListener('change', function(e) {
                        e.stopPropagation();
                        const categoryName = this.getAttribute('data-category');
                        if (categoryName) {
                            changeCustomColor(categoryName, this.value);
                        }
                    });
                    picker.addEventListener('click', e => e.stopPropagation());
                });
                
            } catch (error) {
                console.error('Error updating legend:', error);
                legendContent.innerHTML = '<div class="error-message">Error loading legend</div>';
            }
        }

        // ==================== EVENT HANDLERS ====================
        function toggleGroupFilter(group) {
            const btn = document.getElementById(`group${group}Btn`);
            if (!btn) return;
            
            const index = state.activeGroups.indexOf(group);
            
            if (index > -1) {
                if (state.activeGroups.length > 1) {
                    state.activeGroups.splice(index, 1);
                    btn.classList.remove('active');
                    btn.setAttribute('aria-pressed', 'false');
                } else {
                    showNotification('At least one group must remain active', 'error');
                    return;
                }
            } else {
                state.activeGroups.push(group);
                state.activeGroups.sort();
                btn.classList.add('active');
                btn.setAttribute('aria-pressed', 'true');
            }
            
            updateMap();
        }

        function filterByCategory(category) {
            state.currentFilter = state.currentFilter === category ? null : category;
            updateMap();
            
            if (state.currentFilter) {
                showNotification(`Filtering by: ${category}`, 'info', 2000);
            } else {
                showNotification('Filter cleared', 'info', 2000);
            }
        }

        function clearFilter() {
            state.currentFilter = null;
            const searchInput = document.getElementById('searchInput');
            if (searchInput) searchInput.value = '';
            updateMap();
            showNotification('All filters cleared', 'info', 2000);
        }

        function resetColors() {
            if (Object.keys(state.customColors).length === 0) {
                showNotification('No custom colors to reset', 'info');
                return;
            }
            
            console.log('Resetting all custom colors');
            state.customColors = {};
            assignDriverColors();
            updateMap();
            showNotification('All custom colors reset', 'success');
        }

        function togglePanel() {
            const panel = document.getElementById('leftPanel');
            const toggle = document.getElementById('panelToggle');
            const icon = document.getElementById('panelToggleIcon');
            
            if (panel && toggle && icon) {
                panel.classList.toggle('open');
                icon.textContent = panel.classList.contains('open') ? '‚ñ∂' : '‚óÄ';
            }
        }

        // ==================== SAVE FUNCTIONS ====================
        async function saveMarkerData() {
            const editDriverInput = document.getElementById('editDriver');
            const editGroupInput = document.getElementById('editGroup');
            const saveBtn = document.getElementById('saveBtn');
            
            if (!editDriverInput || !editGroupInput) {
                showNotification('Error: Edit fields not found', 'error');
                return;
            }
            
            const newDriverName = editDriverInput.value.trim();
            const newGroupValue = editGroupInput.value.trim();
            
            if (!state.selectedRow) {
                showNotification('Error: No row selected', 'error');
                return;
            }

            try {
                if (saveBtn) {
                    saveBtn.disabled = true;
                    saveBtn.innerHTML = '‚è≥ Saving...';
                }
                
                const oldDriver = state.selectedRow['Driver'] || '';
                const oldGroup = state.selectedRow['Group'] || '';
                
                const sheetRowIndex = getSheetRowIndex(state.selectedRow);
                
                if (sheetRowIndex === -1) {
                    throw new Error('Could not determine row index');
                }
                
                console.log('Saving to sheet row:', sheetRowIndex, 'for dog:', state.selectedRow['Dog Name']);
                
                state.selectedRow['Driver'] = newDriverName;
                state.selectedRow['Group'] = newGroupValue;
                
                state.markerLookup.clear();
                state.coordinateLookup.clear();
                
                assignDriverColors();
                updateMap();
                
                setTimeout(() => {
                    const dogId = getDogId(state.selectedRow);
                    const markerData = state.markerLookup.get(dogId);
                    if (markerData && markerData.marker) {
                        selectMarker(markerData.marker, state.selectedRow, state.selectedRow['_rowIndex'], markerData.group);
                    }
                }, 100);
                
                showNotification('Saving to Google Sheets...', 'info', 1000);
                
                const payload = {
                    action: 'updateRow',
                    rowIndex: sheetRowIndex,
                    updatedData: {
                        'Driver': newDriverName,
                        'Group': newGroupValue
                    }
                };
                
                await callAppsScript(payload);
                
                showNotification('‚úÖ Data updated in Google Sheets!', 'success', 2000);
                
                if (saveBtn) {
                    saveBtn.disabled = false;
                    saveBtn.innerHTML = 'üíæ Save';
                }
                
                setTimeout(() => {
                    console.log('Reloading data to refresh tooltips...');
                    loadData();
                }, 500);
                
            } catch (error) {
                console.error('Error in saveMarkerData:', error);
                showNotification(`Error saving: ${error.message}`, 'error');
                
                if (saveBtn) {
                    saveBtn.disabled = false;
                    saveBtn.innerHTML = 'üíæ Save';
                }
                
                if (state.selectedRow && typeof oldDriver !== 'undefined') {
                    state.selectedRow['Driver'] = oldDriver;
                    state.selectedRow['Group'] = oldGroup;
                    assignDriverColors();
                    updateMap();
                }
            }
        }

        async function saveDriverName() {
            return saveMarkerData();
        }

        async function bulkUpdateSelected() {
            if (!state.selectionMode) {
                showNotification('Not in selection mode', 'error');
                return;
            }
            
            const bulkInput = document.getElementById('bulkDriverInput');
            const bulkBtn = document.getElementById('bulkUpdateBtn');
            
            if (!bulkInput) {
                showNotification('Interface not ready. Please try again.', 'error');
                return;
            }
            
            const newDriverName = bulkInput.value.trim();
            if (!newDriverName) {
                showNotification('Please enter a driver name', 'error');
                bulkInput.focus();
                return;
            }
            
            if (state.selectedMarkers.size === 0) {
                showNotification('No markers selected', 'error');
                return;
            }
            
            try {
                const validSelectedRows = [];
                const sheetRowIndices = [];
                
                for (const dogId of state.selectedMarkers) {
                    const markerData = state.markerLookup.get(dogId);
                    if (markerData && markerData.row) {
                        const sheetRowIndex = getSheetRowIndex(markerData.row);
                        if (sheetRowIndex !== -1) {
                            validSelectedRows.push(markerData.row);
                            sheetRowIndices.push(sheetRowIndex);
                        }
                    }
                }
                
                if (validSelectedRows.length === 0) {
                    showNotification('No valid markers selected', 'error');
                    return;
                }
                
                if (!confirm(`Update ${validSelectedRows.length} dogs with driver name: "${newDriverName}"?`)) {
                    return;
                }
                
                if (bulkBtn) {
                    bulkBtn.disabled = true;
                    bulkBtn.innerHTML = '‚è≥ Updating...';
                }
                
                const oldValues = validSelectedRows.map(row => ({
                    row: row,
                    oldDriver: row['Driver'] || ''
                }));
                
                validSelectedRows.forEach(row => {
                    row['Driver'] = newDriverName;
                });
                
                state.markerLookup.clear();
                state.coordinateLookup.clear();
                
                assignDriverColors();
                updateMap();
                clearSelection();
                
                showNotification(`Saving ${validSelectedRows.length} updates to Google Sheets...`, 'info');
                
                const updates = sheetRowIndices.map(sheetRowIndex => ({
                    rowIndex: sheetRowIndex,
                    updatedData: {
                        'Driver': newDriverName
                    }
                }));
                
                console.log('Bulk updating rows:', sheetRowIndices);
                
                const payload = {
                    action: 'bulkUpdate',
                    updates: updates
                };
                
                await callAppsScript(payload);
                
                showNotification(`‚úÖ Successfully updated ${validSelectedRows.length} dogs in Google Sheets!`, 'success', 3000);
                
                if (bulkBtn) {
                    bulkBtn.disabled = false;
                    bulkBtn.innerHTML = 'üíæ Update All';
                }
                
                setTimeout(() => {
                    console.log('Reloading data to refresh tooltips after bulk update...');
                    loadData();
                }, 500);
                
            } catch (error) {
                console.error('Bulk update error:', error);
                showNotification(`Error during bulk update: ${error.message}`, 'error');
                
                if (bulkBtn) {
                    bulkBtn.disabled = false;
                    bulkBtn.innerHTML = 'üíæ Update All';
                }
                
                if (oldValues) {
                    oldValues.forEach(({row, oldDriver}) => {
                        row['Driver'] = oldDriver;
                    });
                    assignDriverColors();
                    updateMap();
                }
            }
        }

        function cancelEdit() {
            if (state.selectedMarker && state.selectedRow) {
                const markerData = state.markers.find(m => m && m.marker === state.selectedMarker);
                if (markerData) {
                    const index = state.selectedRow['_rowIndex'] ?? state.allData.indexOf(state.selectedRow);
                    selectMarker(state.selectedMarker, state.selectedRow, index, markerData.group);
                }
            }
        }

        // ==================== INITIALIZATION ====================
        const debouncedUpdateMap = debounce(updateMap, CONFIG.DEBOUNCE_DELAY);

        function initializeApp() {
            try {
                console.log('DOM loaded, initializing application...');
                
                const requiredFeatures = [
                    'Promise' in window,
                    'fetch' in window,
                    'Map' in window,
                    'Set' in window,
                    'requestAnimationFrame' in window
                ];
                
                const missingFeatures = requiredFeatures.filter((feature, index) => {
                    const featureName = ['Promise', 'fetch', 'Map', 'Set', 'requestAnimationFrame'][index];
                    if (!eval(feature)) {
                        console.error(`Missing required feature: ${featureName}`);
                        return true;
                    }
                    return false;
                });
                
                if (missingFeatures.length > 0) {
                    showNotification('Your browser is missing required features. Please use a modern browser.', 'error', 0);
                    return;
                }
                
                initMap();
                loadData();
                
                setTimeout(() => testAppsScriptConnection(), 2000);
                
                const searchInput = document.getElementById('searchInput');
                if (searchInput) {
                    searchInput.addEventListener('input', debouncedUpdateMap);
                    searchInput.addEventListener('search', debouncedUpdateMap);
                }
                
                document.getElementById('group1Btn')?.addEventListener('click', () => toggleGroupFilter(1));
                document.getElementById('group2Btn')?.addEventListener('click', () => toggleGroupFilter(2));
                document.getElementById('group3Btn')?.addEventListener('click', () => toggleGroupFilter(3));
                
                document.getElementById('selectionModeBtn')?.addEventListener('click', toggleSelectionMode);
                document.getElementById('clearSelectionBtn')?.addEventListener('click', clearSelection);
                document.getElementById('resetColorsBtn')?.addEventListener('click', resetColors);
                document.getElementById('showAllBtn')?.addEventListener('click', clearFilter);
                document.getElementById('panelToggle')?.addEventListener('click', togglePanel);
                document.getElementById('testConnectionBtn')?.addEventListener('click', testAppsScriptConnection);
                
                document.addEventListener('keydown', function(e) {
                    if (e.key === 'Escape') {
                        if (state.selectionMode) {
                            toggleSelectionMode();
                        } else if (state.selectedMarker) {
                            state.selectedMarker = null;
                            state.selectedRow = null;
                            updateMap();
                            const detailsContent = document.getElementById('detailsContent');
                            if (detailsContent) {
                                detailsContent.innerHTML = '<div class="no-selection">Click a marker to edit</div>';
                            }
                        }
                    }
                    
                    if ((e.ctrlKey || e.metaKey) && e.key === 'f') {
                        e.preventDefault();
                        const searchInput = document.getElementById('searchInput');
                        if (searchInput) {
                            searchInput.focus();
                            searchInput.select();
                        }
                    }
                });
                
                console.log('Application initialized successfully');
                console.log('v2.7 - Driver name autocomplete enabled');
                console.log('Autocomplete works in both single edit and bulk edit modes');
                
            } catch (error) {
                console.error('Error during application initialization:', error);
                showNotification('Failed to initialize application', 'error', 0);
            }
        }

        // Global functions
        window.filterByCategory = filterByCategory;
        window.clearSelection = clearSelection;
        window.saveDriverName = saveDriverName;
        window.saveMarkerData = saveMarkerData;
        window.cancelEdit = cancelEdit;
        window.bulkUpdateSelected = bulkUpdateSelected;
        window.testAppsScriptConnection = testAppsScriptConnection;

        window.addEventListener('error', function(event) {
            console.error('Global error:', event.error);
            console.error('Stack:', event.error?.stack);
            
            if (event.error?.message?.includes('group') || event.error?.message?.includes('Group')) {
                console.log('Group parsing tip: Supported business codes are DD, SUB, AA, F');
                console.log('Valid patterns: 1, 2, 3, 1DD1, 2F2, 1&2, 1DD&2, 123, 1SUB23, etc.');
            }
        });

        document.addEventListener('DOMContentLoaded', initializeApp);

        console.log('Dog Walking Map v2.7 - Autocomplete Ready');
    </script>
</body>
</html>
